<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[bug-cts-wifilinkstatus报错]]></title>
    <url>%2F2019%2F06%2F16%2Fbug-cts-wifilinkstatus%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[BUG详情 此bug是在cts测试时遇到的 看logcat报错显示是wifigetlinklayerstatus报错。 这个问题遇到很多，cts好几条都是与之相关，还有在设置界面查看电池电量时，切换页面时很慢查看log，也是这个报错 解决方案 导入patch]]></content>
      <categories>
        <category>BUG记录</category>
      </categories>
      <tags>
        <tag>cts</tag>
        <tag>wifi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bug-wifi-p2p认证测试]]></title>
    <url>%2F2019%2F06%2F16%2Fbug-wifi-p2p%E8%AE%A4%E8%AF%81%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[BUG详情 此bug在项目wifi认证阶段出现的 解决方案step112345678adb rootadb pull /vendor/etc/wifi/WCNSS_qcom_cfg.ini .# add/modify below item in your WCNSS_qcom_cfg.ini file.# gApLinkMonitorPeriod = 45# gGoLinkMonitorPeriod = 45# gGoKeepAlivePeriod = 255# gApKeepAlivePeriod = 255adb push WCNSS_qcom_cfg.ini /vendor/etc/wifi/ adb reboot step 2 make sure iwpriv tool in test phone. 123adb rootadb shellwhich iwpriv if output show a path such as ‘/system/bin/iwpriv’ can indicate iwpriv tool in your test phone]]></content>
      <categories>
        <category>BUG记录</category>
      </categories>
      <tags>
        <tag>wifi认证</tag>
        <tag>p2p</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这个夏天好像不一样了哦]]></title>
    <url>%2F2019%2F06%2F15%2F%E8%BF%99%E4%B8%AA%E5%A4%8F%E5%A4%A9%E5%A5%BD%E5%83%8F%E4%B8%8D%E4%B8%80%E6%A0%B7%E4%BA%86%E5%93%A6%2F</url>
    <content type="text"><![CDATA[输入密码，查看文章。 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>生活点滴</category>
      </categories>
      <tags>
        <tag>顾陈城</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[bug]WSC probe request帧错误]]></title>
    <url>%2F2019%2F06%2F01%2Fbug-WSC-probe-request%E5%B8%A7%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[BUG 详情 此bug是在项目在wifi认证阶段出现的，实验室测试出在WSC（WPS）的时候，发现probe request帧格式出现错误。具体说来有两处错误 config methods属性错误 config methods：value长度为2字节，共16位。每一位代表Enrollee或register支持的WSC配置方法。usb, ethernet, label, display, virtual display, physical display, external NFC, internal NFC, NFC interface, push button, virtual push button, physical push button, keypad。按照此项目需要将此属性的 display, virtual display, push button, virtual push button位打开，算出此属性应该为0x2280，而此时测试出的结果为0x3184。 model name等属性值为空 通过抓包发现，model name、manufacturer、model number、serial number 和 device_name 这些属性值为空 解决方案 wpa_supplicant 通过解析wpa_supplicant.conf文件，来获取wifi的相关信息，如果需要更改config methods以及model name等属性，则可以在wpa_supplicant.conf文件中添加相关的词缀。故我在wpa_supplicant.conf中添加如下信息：123456device_name=M690manufacturer=LONGCHEERmodel_name=M690model_number=M690serial_number=123456config methods=push_button virtual_push_button dispaly virtual_display]]></content>
      <categories>
        <category>BUG记录</category>
      </categories>
      <tags>
        <tag>WSC</tag>
        <tag>wifi认证</tag>
        <tag>WPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无奈的一天_20190529]]></title>
    <url>%2F2019%2F05%2F29%2F%E6%97%A0%E5%A5%88%E7%9A%84%E4%B8%80%E5%A4%A9-20190529%2F</url>
    <content type="text"><![CDATA[输入密码，查看文章。 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>生活点滴</category>
      </categories>
      <tags>
        <tag>徐桔红</tag>
        <tag>longcheer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[江湖再见]]></title>
    <url>%2F2019%2F05%2F28%2F%E6%B1%9F%E6%B9%96%E5%86%8D%E8%A7%81%2F</url>
    <content type="text"><![CDATA[离别 上个月，也就是4/28我提出了离职，到现在为止一个月了，今天是我在宽翼的最后一天。和同事进行了交接，办理了离职手续。 思绪 在宽翼不到一年的时间，说真的挺喜欢宽翼的，工作轻松，氛围也好，同事也很nice。如果不是我最近买房了，房贷压力大，我或许还会继续呆下去。当然也有一部分同事的相继离开有关，唉！ 江湖再见 不管如何，宽翼这段时光我会很怀念的，诸位，咱们江湖再见]]></content>
      <categories>
        <category>生活点滴</category>
      </categories>
      <tags>
        <tag>时光小记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sysfs和debugfs接口]]></title>
    <url>%2F2019%2F05%2F27%2Fsysfs%E5%92%8Cdebugfs%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[sysfs sysfs虚拟文件系统是使用kset,kobject,ktype组成一个有层次结构的模型，我们可以通过这个虚拟文件系统查看当前平台中的所有设备。内核也可以通过sysfs向上层传递参数。 sysfs接口apiclass_create 在/sys/class目录下创建class类目录, parameter：THIS_MODULE ， class_name return： struct class 结构体 1class_create(THIS_MODULE, "class_name"); kobject_create_and_add 在/sys目录下创建目录 parameter：class_name ，struct kobject *parent 1struct kobject *kobject_create_and_add(const char *name, struct kobject *parent) sysfs_create_file 在kobj对应目录下创建attr对应属性文件 parameter： kobj 在kobj目录下创建， attr属性文件 1234567891011static int sysfs_create_file(struct kobject *kobj, const struct attribute *attr);struct attribute &#123; const char *name; umode_t mode;#ifdef CONFIG_DEBUG_LOCK_ALLOC bool ignore_lockdep:1; struct lock_class_key *key; struct lock_class_key skey;#endif&#125;; device_create_file1234567891011121314151617181920/** * device_create_file - create sysfs attribute file for device. * @dev: device. * @attr: device attribute descriptor. */int device_create_file(struct device *dev, const struct device_attribute *attr)&#123; int error = 0; if (dev) &#123; WARN(((attr-&gt;attr.mode &amp; S_IWUGO) &amp;&amp; !attr-&gt;store), "Attribute %s: write permission without 'store'\n", attr-&gt;attr.name); WARN(((attr-&gt;attr.mode &amp; S_IRUGO) &amp;&amp; !attr-&gt;show), "Attribute %s: read permission without 'show'\n", attr-&gt;attr.name); error = sysfs_create_file(&amp;dev-&gt;kobj, &amp;attr-&gt;attr); &#125; return error;&#125; sysfs_create_group sysfs_create_group - given a directory kobject, create an attribute group kobj: The kobject to create the group on grp: The attribute group to create 1234int sysfs_create_group(struct kobject *kobj,const struct attribute_group *grp)&#123; return internal_create_group(kobj, 0, grp);&#125; sysfs_create_groups sysfs_create_groups - given a directory kobject, create a bunch of attribute groups kobj: The kobject to create the group on groups: The attribute groups to create, NULL terminated 12345678910111213141516171819int sysfs_create_groups(struct kobject *kobj, const struct attribute_group **groups)&#123; int error = 0; int i; if (!groups) return 0; for (i = 0; groups[i]; i++) &#123; error = sysfs_create_group(kobj, groups[i]); if (error) &#123; while (--i &gt;= 0) sysfs_remove_group(kobj, groups[i]); break; &#125; &#125; return error;&#125; strcut attribute123456789101112131415161718192021222324252627282930313233343536373839404142struct attribute *demo_attr[] = &#123; &amp;demo_kobj_attr_show.attr, &amp;demo_kobj_attr_store.attr, NULL, //必须要有&#125;;ssize_t demo_show(struct kobject *kobj,struct kobj_attribute *attr,char *ubuf)&#123; char info[] = "kernel show is called\n"; return sprintf(ubuf,"%s",info);&#125;ssize_t demo_store(struct kobject *kobj,struct kobj_attribute *attr,const char *ubuf,size_t count)&#123; strncpy(kbuf,ubuf,count); printk("recv from user %s\n",kbuf); return count;&#125;#if 0struct kobj_attribute demo_kobj_attr_show = &#123; .attr = &#123; .name = "show",//shou就是一个属性文件名 .mode = S_IRUSR, &#125;, .show = demo_show,&#125;;struct kobj_attribute demo_kobj_attr_store = &#123; .attr = &#123; .name = "store",//也是一个属性文件名 .mode = S_IWUSR, &#125;, .store = demo_store,&#125;;#else//show和store是属性文件名struct kobj_attribute demo_kobj_attr_show = __ATTR(show,S_IRUSR,demo_show,NULL);struct kobj_attribute demo_kobj_attr_store = __ATTR(store,S_IWUSR,NULL,demo_store);#endif DEVICE_ATTR12#define DEVICE_ATTR(_name, _mode, _show, _store) \ struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show, _store) 代码实例 使用内核提供的实例代码：samples/kobject/kset-example.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284/* * Sample kset and ktype implementation * * Copyright (C) 2004-2007 Greg Kroah-Hartman &lt;greg@kroah.com&gt; * Copyright (C) 2007 Novell Inc. * * Released under the GPL version 2 only. * */#include &lt;linux/kobject.h&gt;#include &lt;linux/string.h&gt;#include &lt;linux/sysfs.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/init.h&gt;/* * This module shows how to create a kset in sysfs called * /sys/kernel/kset-example * Then tree kobjects are created and assigned to this kset, "foo", "baz", * and "bar". In those kobjects, attributes of the same name are also * created and if an integer is written to these files, it can be later * read out of it. *//* * This is our "object" that we will create a few of and register them with * sysfs. */struct foo_obj &#123; struct kobject kobj; int foo; int baz; int bar;&#125;;#define to_foo_obj(x) container_of(x, struct foo_obj, kobj)/* a custom attribute that works just for a struct foo_obj. */struct foo_attribute &#123; struct attribute attr; ssize_t (*show)(struct foo_obj *foo, struct foo_attribute *attr, char *buf); ssize_t (*store)(struct foo_obj *foo, struct foo_attribute *attr, const char *buf, size_t count);&#125;;#define to_foo_attr(x) container_of(x, struct foo_attribute, attr)/* * The default show function that must be passed to sysfs. This will be * called by sysfs for whenever a show function is called by the user on a * sysfs file associated with the kobjects we have registered. We need to * transpose back from a "default" kobject to our custom struct foo_obj and * then call the show function for that specific object. */static ssize_t foo_attr_show(struct kobject *kobj, struct attribute *attr, char *buf)&#123; struct foo_attribute *attribute; struct foo_obj *foo; attribute = to_foo_attr(attr); foo = to_foo_obj(kobj); if (!attribute-&gt;show) return -EIO; return attribute-&gt;show(foo, attribute, buf);&#125;/* * Just like the default show function above, but this one is for when the * sysfs "store" is requested (when a value is written to a file.) */static ssize_t foo_attr_store(struct kobject *kobj, struct attribute *attr, const char *buf, size_t len)&#123; struct foo_attribute *attribute; struct foo_obj *foo; attribute = to_foo_attr(attr); foo = to_foo_obj(kobj); if (!attribute-&gt;store) return -EIO; return attribute-&gt;store(foo, attribute, buf, len);&#125;/* Our custom sysfs_ops that we will associate with our ktype later on */static const struct sysfs_ops foo_sysfs_ops = &#123; .show = foo_attr_show, .store = foo_attr_store,&#125;;/* * The release function for our object. This is REQUIRED by the kernel to * have. We free the memory held in our object here. * * NEVER try to get away with just a "blank" release function to try to be * smarter than the kernel. Turns out, no one ever is... */static void foo_release(struct kobject *kobj)&#123; struct foo_obj *foo; foo = to_foo_obj(kobj); kfree(foo);&#125;/* * The "foo" file where the .foo variable is read from and written to. */static ssize_t foo_show(struct foo_obj *foo_obj, struct foo_attribute *attr, char *buf)&#123; return sprintf(buf, "%d\n", foo_obj-&gt;foo);&#125;static ssize_t foo_store(struct foo_obj *foo_obj, struct foo_attribute *attr, const char *buf, size_t count)&#123; sscanf(buf, "%du", &amp;foo_obj-&gt;foo); return count;&#125;/* Sysfs attributes cannot be world-writable. */static struct foo_attribute foo_attribute = __ATTR(foo, 0664, foo_show, foo_store);/* * More complex function where we determine which variable is being accessed by * looking at the attribute for the "baz" and "bar" files. */static ssize_t b_show(struct foo_obj *foo_obj, struct foo_attribute *attr, char *buf)&#123; int var; if (strcmp(attr-&gt;attr.name, "baz") == 0) var = foo_obj-&gt;baz; else var = foo_obj-&gt;bar; return sprintf(buf, "%d\n", var);&#125;static ssize_t b_store(struct foo_obj *foo_obj, struct foo_attribute *attr, const char *buf, size_t count)&#123; int var; sscanf(buf, "%du", &amp;var); if (strcmp(attr-&gt;attr.name, "baz") == 0) foo_obj-&gt;baz = var; else foo_obj-&gt;bar = var; return count;&#125;static struct foo_attribute baz_attribute = __ATTR(baz, 0664, b_show, b_store);static struct foo_attribute bar_attribute = __ATTR(bar, 0664, b_show, b_store);/* * Create a group of attributes so that we can create and destroy them all * at once. */static struct attribute *foo_default_attrs[] = &#123; &amp;foo_attribute.attr, &amp;baz_attribute.attr, &amp;bar_attribute.attr, NULL, /* need to NULL terminate the list of attributes */&#125;;/* * Our own ktype for our kobjects. Here we specify our sysfs ops, the * release function, and the set of default attributes we want created * whenever a kobject of this type is registered with the kernel. */static struct kobj_type foo_ktype = &#123; .sysfs_ops = &amp;foo_sysfs_ops, .release = foo_release, .default_attrs = foo_default_attrs,&#125;;static struct kset *example_kset;static struct foo_obj *foo_obj;static struct foo_obj *bar_obj;static struct foo_obj *baz_obj;static struct foo_obj *create_foo_obj(const char *name)&#123; struct foo_obj *foo; int retval; /* allocate the memory for the whole object */ foo = kzalloc(sizeof(*foo), GFP_KERNEL); if (!foo) return NULL; /* * As we have a kset for this kobject, we need to set it before calling * the kobject core. */ //修改foo上层kset为example_kset目录 foo-&gt;kobj.kset = example_kset; /* * Initialize and add the kobject to the kernel. All the default files * will be created here. As we have already specified a kset for this * kobject, we don't have to set a parent for the kobject, the kobject * will be placed beneath that kset automatically. */ retval = kobject_init_and_add(&amp;foo-&gt;kobj, &amp;foo_ktype, NULL, "%s", name); if (retval) &#123; kobject_put(&amp;foo-&gt;kobj); return NULL; &#125; /* * We are always responsible for sending the uevent that the kobject * was added to the system. */ kobject_uevent(&amp;foo-&gt;kobj, KOBJ_ADD); return foo;&#125;static void destroy_foo_obj(struct foo_obj *foo)&#123; kobject_put(&amp;foo-&gt;kobj);&#125;static int __init example_init(void)&#123; /* * Create a kset with the name of "kset_example", * located under /sys/kernel/ */ //在/sys/kernel/下创建kset_example目录 example_kset = kset_create_and_add("kset_example", NULL, kernel_kobj); if (!example_kset) return -ENOMEM; /* * Create three objects and register them with our kset */ //在/sys/kernel/kset_example下创建foo、bar、baz三个文件夹 foo_obj = create_foo_obj("foo"); if (!foo_obj) goto foo_error; bar_obj = create_foo_obj("bar"); if (!bar_obj) goto bar_error; baz_obj = create_foo_obj("baz"); if (!baz_obj) goto baz_error; return 0;baz_error: destroy_foo_obj(bar_obj);bar_error: destroy_foo_obj(foo_obj);foo_error: kset_unregister(example_kset); return -EINVAL;&#125;static void __exit example_exit(void)&#123; destroy_foo_obj(baz_obj); destroy_foo_obj(bar_obj); destroy_foo_obj(foo_obj); kset_unregister(example_kset);&#125;module_init(example_init);module_exit(example_exit);MODULE_LICENSE("GPL");MODULE_AUTHOR("Greg Kroah-Hartman &lt;greg@kroah.com&gt;"); debugfs DebugFS，顾名思义，是一种用于内核调试的虚拟文件系统，内核开发者通过debugfs和用户空间交换数据。通常情况下，最常用的内核调试手段是printk。但printk并不是所有情况都好用，比如打印的数据可能过多，我们真正关心的数据在大量的输出里不是那么一目了然；或者我们在调试时可能需要修改某些内核变量，这种情况下printk就无能为力，而如果为了修改某个值重新编译内核或者驱动又过于低效，此时就需要一个临时的文件系统可以把我们需要关心的数据映射到用户空间。 debugfs接口apidebugfs_create_dir123456789101112131415161718192021222324/** * debugfs_create_dir - create a directory in the debugfs filesystem * @name: a pointer to a string containing the name of the directory to * create. * @parent: a pointer to the parent dentry for this file. This should be a * directory dentry if set. If this parameter is NULL, then the * directory will be created in the root of the debugfs filesystem. * * This function creates a directory in debugfs with the given name. * * This function will return a pointer to a dentry if it succeeds. This * pointer must be passed to the debugfs_remove() function when the file is * to be removed (no automatic cleanup happens if your module is unloaded, * you are responsible here.) If an error occurs, %NULL will be returned. * * If debugfs is not enabled in the kernel, the value -%ENODEV will be * returned. */struct dentry *debugfs_create_dir(const char *name, struct dentry *parent) &#123; return __create_file(name, S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO, parent, NULL, NULL);&#125;EXPORT_SYMBOL_GPL(debugfs_create_dir); debugfs_create_file123456789101112131415161718192021222324252627282930313233343536373839/** * debugfs_create_file - create a file in the debugfs filesystem * @name: a pointer to a string containing the name of the file to create. * @mode: the permission that the file should have. * @parent: a pointer to the parent dentry for this file. This should be a * directory dentry if set. If this parameter is NULL, then the * file will be created in the root of the debugfs filesystem. * @data: a pointer to something that the caller will want to get to later * on. The inode.i_private pointer will point to this value on * the open() call. * @fops: a pointer to a struct file_operations that should be used for * this file. * * This is the basic "create a file" function for debugfs. It allows for a * wide range of flexibility in creating a file, or a directory (if you want * to create a directory, the debugfs_create_dir() function is * recommended to be used instead.) * * This function will return a pointer to a dentry if it succeeds. This * pointer must be passed to the debugfs_remove() function when the file is * to be removed (no automatic cleanup happens if your module is unloaded, * you are responsible here.) If an error occurs, %NULL will be returned. * * If debugfs is not enabled in the kernel, the value -%ENODEV will be * returned. */struct dentry *debugfs_create_file(const char *name, umode_t mode, struct dentry *parent, void *data, const struct file_operations *fops) &#123; switch (mode &amp; S_IFMT) &#123; case S_IFREG: case 0: break; default: BUG(); &#125; return __create_file(name, mode, parent, data, fops); &#125; EXPORT_SYMBOL_GPL(debugfs_create_file); 代码实例 下方代码的效果：在/sys/kernel/debug下创建bm_battery_debug目录，以及在此目录下创建bm_battery_vadc文件，并提供了show接口，用来查询电池的电压adc和温度adc值。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955/* * Power supply driver for the aw3215 emulator * * Copyright (C) 2008 Google, Inc. * Copyright (C) 2012 Intel, Inc. * Copyright (C) 2013 Intel, Inc. * Author: Mike Lockwood &lt;lockwood@android.com&gt; * * This software is licensed under the terms of the GNU General Public * License version 2, as published by the Free Software Foundation, and * may be copied, distributed, and modified under those terms. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU General Public License for more details. */#include &lt;linux/module.h&gt;#include &lt;linux/err.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/power_supply.h&gt;#include &lt;linux/types.h&gt;#include &lt;linux/pci.h&gt;#include &lt;linux/interrupt.h&gt;#include &lt;linux/io.h&gt;#include &lt;linux/gpio.h&gt;#include &lt;linux/of_gpio.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/qpnp/qpnp-adc.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/workqueue.h&gt;#include &lt;linux/notifier.h&gt;#include &lt;linux/export.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/errno.h&gt;#include &lt;asm/delay.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/timer.h&gt;#include &lt;linux/usb/msm_hsusb.h&gt;#include &lt;linux/reboot.h&gt;#include "../../include/bmtfeatures.h"#include &lt;linux/fs.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;linux/debugfs.h&gt;#include &lt;linux/seq_file.h&gt;#define CUTOFF_CUR_LEVEL 2#define ADC_BUFF_LEN 100#define PERCENT_BUFF_LEN 100static int adc_buff[ADC_BUFF_LEN] = &#123;0&#125;;static int percent_buff[PERCENT_BUFF_LEN] = &#123;0&#125;;static bool charge_full_mask=false;static int bat_get_chg_cap_percent(int64_t bat_vol);static int bat_get_dischg_cap_percent(int64_t bat_vol);static int64_t batt_avg_adc(int64_t bat_voltage);static int batt_avg_percent(int percent);static int get_bm_ftm(void);static unsigned char retry_cnt = 0;static unsigned char init_temperature_config_OK = 0;static unsigned char init_bm_ftm_OK = 0;static int bm_ftm_mode = 0;// r600 battery capacity table //index is the percent% of battery capacity ,so index 0 is 0, index 101 is +inf//value is in mV//this battery's nominal capacity is:2000mAh,step is 20mAh#if 0static int r700_chg_bat_voltage[102]=&#123; 0, 3309,3318,3327,3336,3345,3354,3363,3372,3381,3390, 3399,3408,3417,3426,3435,3444,3453,3462,3471,3480, 3489,3498,3507,3516,3525,3534,3543,3552,3561,3570, 3579,3588,3597,3606,3615,3624,3633,3642,3651,3660, 3669,3678,3687,3696,3705,3714,3723,3732,3741,3750, 3759,3768,3777,3786,3795,3804,3813,3822,3831,3840, 3849,3858,3867,3876,3885,3894,3903,3912,3921,3930, 3939,3948,3957,3966,3975,3984,3993,4002,4011,4020, 4029,4038,4047,4056,4065,4074,4083,4092,4101,4110, 4119,4128,4137,4146,4155,4164,4173,4182,4191,4200, LONG_MAX&#125;;static int r700_dischg_bat_voltage[102]=&#123; 0, 3259,3268,3277,3286,3295,3304,3313,3322,3331,3340, 3349,3358,3367,3376,3385,3394,3403,3412,3421,3430, 3439,3448,3457,3466,3475,3484,3493,3502,3511,3520, 3529,3538,3547,3556,3565,3574,3583,3592,3601,3610, 3619,3628,3637,3646,3655,3664,3673,3682,3691,3700, 3709,3718,3727,3736,3745,3754,3763,3772,3781,3790, 3799,3808,3817,3826,3835,3844,3853,3862,3871,3880, 3889,3898,3907,3916,3925,3934,3943,3952,3961,3970, 3979,3988,3997,4006,4015,4024,4033,4042,4051,4060, 4069,4078,4087,4096,4105,4114,4123,4132,4141,4150, LONG_MAX&#125;;#elsestatic int r700_chg_bat_voltage[102]=&#123; 0, 3300,3320,3340,3360,3380,3400,3420,3440,3460,3480, 3500,3520,3540,3560,3580,3600,3620,3640,3660,3680, 3700,3706,3712,3718,3724,3730,3736,3742,3748,3754, 3760,3766,3772,3778,3784,3790,3796,3802,3808,3814, 3820,3826,3832,3838,3844,3850,3856,3862,3868,3874, 3880,3886,3892,3898,3904,3910,3916,3922,3928,3934, 3940,3946,3952,3958,3964,3970,3976,3982,3988,3994, 4000,4006,4012,4018,4024,4030,4036,4042,4048,4054, 4060,4066,4072,4078,4081,4084,4087,4090,4095,4110, 4119,4128,4137,4146,4155,4164,4173,4182,4191,4200, LONG_MAX&#125;;static int r700_dischg_bat_voltage[102]=&#123; 0, 3250,3270,3290,3310,3330,3350,3370,3390,3410,3430, 3450,3470,3490,3510,3530,3550,3570,3590,3610,3630, 3650,3656,3662,3668,3674,3680,3686,3692,3698,3704, 3710,3716,3722,3728,3734,3740,3746,3852,3858,3764, 3770,3776,3782,3788,3794,3800,3806,3812,3818,3824, 3830,3836,3842,3848,3854,3860,3866,3872,3878,3884, 3890,3896,3902,3908,3914,3920,3926,3932,3938,3944, 3950,3956,3962,3968,3974,3980,3986,3992,3998,4004, 4010,4016,4022,4028,4031,4034,4037,4040,4045,4060, 4069,4078,4087,4096,4105,4114,4123,4132,4141,4150, LONG_MAX&#125;;#endif#define SHUT_DOWN_VOLTAGE 3300struct aw3215_battery_data &#123; int ctrl_gpio; int stat_gpio; int battery_temperature_vadc;// battery temperature vadc int64_t battery_capacity_vadc; // battery capacity vadc int cur_percent; int old_percent; bool online; bool old_online; bool ac_or_usb; bool old_ac_or_usb; bool full_changed; bool first; int status; int health; int old_health; int present; int old_present; spinlock_t lock; struct qpnp_vadc_chip *vadc; enum qpnp_vadc_channels adc_channel; struct workqueue_struct *volt_adc_queue; struct delayed_work volt_adc_work; struct power_supply battery; struct power_supply ac; struct notifier_block aw_notifier; struct timer_list timer; struct dentry *bm_aw3215_debugfs;&#125;;static struct aw3215_battery_data *battery_data;static void set_cutoff_cur_func(unsigned long var);/* add emergency hot temperature */struct bm_temperature_me_type &#123; int te_status; int te_range; void (*bm_temperature_cb)(int);&#125;;enum&#123; BM_BATTERY_TEMP_CLASS_EMERGENCY_HOT, BM_BATTERY_TEMP_CLASS_HOT, BM_BATTERY_TEMP_CLASS_GOOD, BM_BATTERY_TEMP_CLASS_COLD,&#125;;static void bm_temp_emergency_hot_callback(int result_adc);static void bm_temp_hot_callback(int result_adc);static void bm_temp_good_callback(int result_adc);static void bm_temp_cold_callback(int result_adc);static struct bm_temperature_me_type bm_temperature_me[] = &#123; &#123;POWER_SUPPLY_HEALTH_OVERHEAT, TEMP_EMERGENCY_HOT_VOLTAGE, bm_temp_emergency_hot_callback&#125;, &#123;POWER_SUPPLY_HEALTH_OVERHEAT, TEMP_HOT_VOLTAGE, bm_temp_hot_callback&#125;, &#123;POWER_SUPPLY_HEALTH_GOOD, TEMP_COLD_VOLTAGE, bm_temp_good_callback&#125;, &#123;POWER_SUPPLY_HEALTH_COLD, TEMP_OVER_COLD_VOLTAGE, bm_temp_cold_callback&#125;,&#125;;#define BM_BATTERY_TEMPERATURE_CONFIG_FILE "/etc/backup/bm_temp_cfg"/* add end */extern int aw_register_client(struct notifier_block *nb);extern int aw_unregister_client(struct notifier_block *nb);/* add debugfs support for aw3215_battery */#define BM_AW3215_DEBUGFS_DIR "bm_battery_debug"#define BM_AW3215_DEBUGFS_BATTERY_FILE "bm_battery_vadc"static int bm_aw3215_debugfs_open(struct inode *node, struct file *file);static int bm_aw3215_debugfs_show(struct seq_file *s, void *what);/* add end */static int get_bm_ftm(void)&#123; struct file *filep = NULL; char buf[3]=&#123;0&#125;; loff_t pos = 0; int ret = 0; mm_segment_t old_fs; old_fs = get_fs(); //printk("----enter get bm_ftm\n"); filep=filp_open("/etc/backup/bmftm",O_CREAT | O_RDWR,0); if(IS_ERR(filep))&#123; printk("error- filp_open /etc/backup/bmftm filed!!!\n"); return -1; &#125; set_fs(KERNEL_DS); vfs_read(filep, buf, sizeof(buf), &amp;pos); filp_close(filep, NULL); init_bm_ftm_OK = 1; set_fs(old_fs); ret = memcmp(buf,"1",1); if(!ret)&#123; printk("----enter get bm_ftm 1\n"); return 1; &#125; else&#123; printk("----enter get bm_ftm 0\n"); return 0; &#125;&#125;static void init_temperature_config(void)&#123; struct file *filep; char buf[100] = &#123;0&#125;; loff_t pos = 0; mm_segment_t old_fs; int e_cfg = 0, h_cfg = 0, g_cfg = 0, c_cfg = 0; old_fs = get_fs(); filep = filp_open(BM_BATTERY_TEMPERATURE_CONFIG_FILE, O_RDONLY, 0); if(IS_ERR(filep))&#123; //printk("aw3215_charger: error- filp_open %s filed!!!maybe do not configed or file system not inited.\n", BM_BATTERY_TEMPERATURE_CONFIG_FILE); return ; &#125; set_fs(KERNEL_DS); vfs_read(filep, buf, sizeof(buf), &amp;pos); filp_close(filep, NULL); if (strchr(buf, ',')) sscanf(buf, "%d,%d,%d,%d", &amp;e_cfg, &amp;h_cfg, &amp;g_cfg, &amp;c_cfg); else &#123; pr_err("aw3215_battery15_charger: %s, error, get config temperture str:%s\n", __func__, buf); set_fs(old_fs); return ; &#125; pr_info("aw3215_charger: %s, config temperature:%d,%d,%d,%d\n", __func__, e_cfg, h_cfg, g_cfg, c_cfg); set_fs(old_fs); if (e_cfg) bm_temperature_me[BM_BATTERY_TEMP_CLASS_EMERGENCY_HOT].te_range = e_cfg; if (h_cfg) bm_temperature_me[BM_BATTERY_TEMP_CLASS_HOT].te_range = h_cfg; if (g_cfg) bm_temperature_me[BM_BATTERY_TEMP_CLASS_GOOD].te_range = g_cfg; if (c_cfg) bm_temperature_me[BM_BATTERY_TEMP_CLASS_COLD].te_range = c_cfg; init_temperature_config_OK = 1; return ;&#125;static int init_bm_ftm_mode(void)&#123; return get_bm_ftm();&#125;#define BM_TEMPERTURE_HOT_RETRY 50static void bm_temp_emergency_hot_callback(int result_adc)&#123; if(!bm_ftm_mode) &#123; pr_emerg("get_tmp_adc_val result_adc = %d\nemergency battery hot!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n",result_adc); kernel_power_off(); &#125; else pr_emerg("get_tmp_adc_val result_adc = %d\nemergency battery hot, but it is now ftm mode 1.!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n",result_adc); return ;&#125;static void bm_temp_hot_callback(int result_adc)&#123; if(!bm_ftm_mode) &#123; pr_emerg("get_tmp_adc_val result_adc = %d\nbattery hot!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n",result_adc); if (retry_cnt &gt; BM_TEMPERTURE_HOT_RETRY) &#123; kernel_power_off(); &#125; retry_cnt++; &#125; else pr_emerg("get_tmp_adc_val result_adc = %d\nbattery hot, but it its now ftm mode 1.!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n",result_adc); return ;&#125;static void bm_temp_good_callback(int result_adc)&#123; retry_cnt = 0; return ;&#125;static void bm_temp_cold_callback(int result_adc)&#123; retry_cnt = 0;#if 0 if(!bm_ftm_mode) &#123; pr_emerg("get_tmp_adc_val RESULT_UNSUP_HOST_adc = %d\nbattery cold!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n",result_adc); kernel_power_off(); &#125; else pr_emerg("get_tmp_adc_val result_adc = %d\nbattery colde, but it is now ftm mode 1.!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n",result_adc);#endif return ;&#125;static int get_tmp_adc_val(struct aw3215_battery_data *data)&#123; int32_t rc; struct qpnp_vadc_result adc_result; int result_adc,a; long sum=0; int num = sizeof(bm_temperature_me) / sizeof(struct bm_temperature_me_type); int i = 0; //printk("get_tmp_adc_val start...\n"); if(!data-&gt;vadc) return 0 ; for(a=0;a &lt; 6;a++) &#123; rc = qpnp_vadc_read(data-&gt;vadc,P_MUX6_1_1,&amp;adc_result); if (rc) &#123; printk("error- reading tmp adc channel rc = %d\n", rc); return rc; &#125; sum += (int)adc_result.physical; &#125; result_adc = (int)(sum/6); //printk("get_tmp_adc_val battery_temperature_vadc = %d\n",result_adc); #if 0 switch(result_adc)&#123;#ifdef RAISE_HOT_TMP case 0 ... CPG_TEMP_HOT_VOLTAGE:#else case 0 ... TEMP_HOT_VOLTAGE:#endif data-&gt;health = POWER_SUPPLY_HEALTH_OVERHEAT; data-&gt;present = 1; if(get_bm_ftm()) kernel_power_off(); break ;#ifdef RAISE_HOT_TMP case CPG_TEMP_HOT_VOLTAGE + 1 ... TEMP_COLD_VOLTAGE:#else case TEMP_HOT_VOLTAGE + 1 ... TEMP_COLD_VOLTAGE:#endif data-&gt;health = POWER_SUPPLY_HEALTH_GOOD ; data-&gt;present = 1; break ; case TEMP_COLD_VOLTAGE + 1 ... TEMP_OVER_COLD_VOLTAGE: data-&gt;health = POWER_SUPPLY_HEALTH_COLD; data-&gt;present = 1; if(get_bm_ftm()) kernel_power_off(); break ; default: data-&gt;health = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE ; data-&gt;present = 0; break ; &#125;#else for (i = 0; i &lt; num; i++) &#123; if(result_adc &lt; bm_temperature_me[i].te_range)&#123; break; &#125; &#125; printk("result_adc = %d\n",result_adc); printk("bm_ftm_mode = %d\n",bm_ftm_mode); if(i != num)&#123; printk("bm_temperature_me[%d].te_status = %d\n", i, bm_temperature_me[i].te_status); data-&gt;health = bm_temperature_me[i].te_status; data-&gt;present = 1; if (bm_temperature_me[i].bm_temperature_cb) bm_temperature_me[i].bm_temperature_cb(result_adc); &#125;else&#123; printk("power supply health unspec failed!\n"); data-&gt;health = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE; data-&gt;present = 0; &#125;#endif// if(data-&gt;old_health != data-&gt;health || data-&gt;old_present != data-&gt;present) // power_supply_changed(&amp;data-&gt;battery); // data-&gt;old_health = data-&gt;health; //data-&gt;old_present = data-&gt;present; //printk("get_tmp_adc_val battery_temperature_vadc = %d\n",result_adc); //printk("get_tmp_adc_val end...\n"); return result_adc;&#125;static int r700_get_battery_voltage(struct aw3215_battery_data *data,enum qpnp_vadc_channels channel)&#123; int32_t rc; struct qpnp_vadc_result adc_result; int percent,a; int64_t bat_voltage =0;// in uV int64_t r700_bat_voltage =0; //printk("r700_get_battery_voltage start...\n"); if(!data-&gt;vadc) return 0 ; for(a=0;a &lt; 6;a++) &#123; rc = qpnp_vadc_read(data-&gt;vadc,channel,&amp;adc_result); if (rc) &#123; printk("error- reading voltage adc channel =%d,rc = %d\n",channel, rc); return rc; &#125; bat_voltage += adc_result.physical; &#125; do_div(bat_voltage,6000); r700_bat_voltage = batt_avg_adc(bat_voltage); battery_data-&gt;battery_capacity_vadc = r700_bat_voltage; //printk("get_battery_voltage bat_voltage = %lld\n",r700_bat_voltage);#if 1 if(data-&gt;online) &#123; data-&gt;full_changed = gpio_get_value(data-&gt;stat_gpio); if(data-&gt;full_changed)&#123; percent = 100; &#125; else&#123; percent = bat_get_chg_cap_percent(r700_bat_voltage); //printk("bat_get_chg_cap_percent = %d\n",percent); &#125; &#125; else &#123; percent = bat_get_dischg_cap_percent(r700_bat_voltage); //printk("bat_get_dischg_cap_percent = %d\n",percent); &#125;#endif // percent = bat_get_chg_cap_percent(r700_bat_voltage); //r700_percent = batt_avg_percent(percent); //if(percent &lt; 2) if(r700_bat_voltage &lt; SHUT_DOWN_VOLTAGE) &#123; kernel_power_off(); &#125; //printk("r700_get_battery_voltage bat_voltage = %lld\n",r700_bat_voltage); //printk("r700_get_percent = %d\n",percent); return percent;&#125;static int aw3215_ac_get_property(struct power_supply *psy, enum power_supply_property psp, union power_supply_propval *val)&#123; struct aw3215_battery_data *data = container_of(psy,struct aw3215_battery_data, ac); int ret = 0; switch (psp) &#123; case POWER_SUPPLY_PROP_ONLINE: if(data-&gt;online) &#123; if(data-&gt;ac_or_usb) val-&gt;intval = 0; else val-&gt;intval = 1; &#125;else&#123; val-&gt;intval = 0; //charge_full_mask=false; &#125; //printk("ac get----------------------------ONLINE property intval = %d \n",val-&gt;intval); break; case POWER_SUPPLY_PROP_TYPE: if(data-&gt;ac_or_usb) //val-&gt;strval = "ac"; val-&gt;intval = 3; else //val-&gt;strval = "usb"; val-&gt;intval = 4; // printk("ac get --------------------------- POWER_SUPPLY_PROP_TYPE %d \n",val-&gt;intval); break; default: ret = -EINVAL; break; &#125; return ret;&#125;static int aw3215_battery_get_property(struct power_supply *psy, enum power_supply_property psp, union power_supply_propval *val)&#123; struct aw3215_battery_data *data = container_of(psy,struct aw3215_battery_data, battery); int ret = 0; switch (psp) &#123; case POWER_SUPPLY_PROP_STATUS: val-&gt;intval = data-&gt;status;//aw3215_BATTERY_READ(data, BATTERY_STATUS); //printk("battery get status property intval = %d \n",data-&gt;status); break; case POWER_SUPPLY_PROP_HEALTH: val-&gt;intval = data-&gt;health;//aw3215_BATTERY_READ(data, BATTERY_HEALTH); //printk("battery get health property intval = %d \n",val-&gt;intval); break; case POWER_SUPPLY_PROP_PRESENT: val-&gt;intval = data-&gt;present; //printk("battery get present property intval = %d \n",val-&gt;intval); break; case POWER_SUPPLY_PROP_TECHNOLOGY: val-&gt;intval = POWER_SUPPLY_TECHNOLOGY_LION; //printk("battery get technology property intval = %d \n",val-&gt;intval); break; case POWER_SUPPLY_PROP_CAPACITY: val-&gt;intval = data-&gt;cur_percent; //printk("battery get capacity property intval = %d \n",val-&gt;intval); break; default: ret = -EINVAL; break; &#125; return ret;&#125;static enum power_supply_property aw3215_battery_props[] = &#123; POWER_SUPPLY_PROP_STATUS, POWER_SUPPLY_PROP_HEALTH, POWER_SUPPLY_PROP_PRESENT, POWER_SUPPLY_PROP_TECHNOLOGY, POWER_SUPPLY_PROP_CAPACITY,&#125;;static enum power_supply_property aw3215_ac_props[] = &#123; POWER_SUPPLY_PROP_ONLINE, POWER_SUPPLY_PROP_TYPE,&#125;;static void set_cutoff_using_func(unsigned long var)&#123; int i; gpio_set_value(battery_data-&gt;ctrl_gpio, 0); msleep(20); for (i=0;i&lt;var;i++)&#123; gpio_set_value(battery_data-&gt;ctrl_gpio, 0); udelay(2); gpio_set_value(battery_data-&gt;ctrl_gpio, 1); udelay(2); &#125; //printk("set_cutoff_using_func var = %ld\n",var );&#125;static void get_volt_val_func(struct work_struct *work)&#123; struct aw3215_battery_data *data = container_of(work, struct aw3215_battery_data, volt_adc_work.work); //printk("get_volt_val_func start...\n"); data-&gt;adc_channel = VBAT_SNS; data-&gt;cur_percent = r700_get_battery_voltage(data,data-&gt;adc_channel); if(data-&gt;first) &#123; //printk("get_volt_val_func start data-&gt;first...\n"); data-&gt;first = false; data-&gt;old_percent = r700_get_battery_voltage(data,data-&gt;adc_channel); if(99&lt;data-&gt;old_percent) data-&gt;old_percent = data-&gt;cur_percent -1; if(1 &gt;data-&gt;old_percent) data-&gt;old_percent = data-&gt;cur_percent +1; &#125; if (!init_temperature_config_OK) init_temperature_config(); if (!init_bm_ftm_OK) bm_ftm_mode = init_bm_ftm_mode(); if((charge_full_mask)&amp;&amp;(data-&gt;cur_percent &gt; 99))&#123; data-&gt;cur_percent = 100; data-&gt;old_percent = 100; data-&gt;status =POWER_SUPPLY_STATUS_FULL; &#125;else&#123; if(data-&gt;online) &#123; //printk("get_volt_val_func start data-&gt;online...\n"); data-&gt;full_changed = gpio_get_value(data-&gt;stat_gpio); if(data-&gt;full_changed)&#123; charge_full_mask=true; //printk("-----------get_volt_val_func start data-&gt;online data-&gt;full_changed = ...\n"); &#125; set_cutoff_using_func(CUTOFF_CUR_LEVEL); data-&gt;status =POWER_SUPPLY_STATUS_CHARGING ; if(data-&gt;cur_percent &gt;= 100)&#123; data-&gt;old_percent = 99; data-&gt;cur_percent = 99; &#125; if(data-&gt;old_percent &gt; data-&gt;cur_percent)&#123; data-&gt;cur_percent = data-&gt;old_percent; &#125;else&#123; data-&gt;old_percent = data-&gt;cur_percent; &#125; &#125;else&#123; //printk("get_volt_val_func start data-&gt;offline...\n"); data-&gt;status = POWER_SUPPLY_STATUS_DISCHARGING; if(data-&gt;cur_percent &gt; data-&gt;old_percent) data-&gt;cur_percent = data-&gt;old_percent; else data-&gt;old_percent = data-&gt;cur_percent; &#125; &#125; power_supply_changed(&amp;data-&gt;battery); msleep(3000); data-&gt;battery_temperature_vadc = get_tmp_adc_val(data); queue_delayed_work(data-&gt;volt_adc_queue,&amp;data-&gt;volt_adc_work,3*HZ); //printk("&gt;&gt;&gt;&gt;&gt;&gt;data-&gt;old_percent = %d\n",data-&gt;old_percent); //printk("&gt;&gt;&gt;&gt;&gt;&gt;data-&gt;cur_percent = %d\n",data-&gt;cur_percent); //printk("get_volt_val_func end...\n");&#125;static int aw_notifier_callback(struct notifier_block *self, unsigned long event, void *data)&#123; //printk("aw_notifier_callback start ....\n"); struct aw3215_battery_data *pdata = container_of(self, struct aw3215_battery_data, aw_notifier); int *blank; if (event == 123 ) &#123; blank = data; pdata-&gt;online = true; if (*blank == 4)&#123; //printk("~~~~~~~~~~data = %ld blank= %d\n",event,*blank); pdata-&gt;ac_or_usb= true; &#125; else if (*blank == 5)&#123; pdata-&gt;ac_or_usb= false; //printk("~~~~~~~~~~data = %ld blank= %d\n",event,*blank); &#125; power_supply_changed(&amp;pdata-&gt;ac); &#125;else if(event == 456)&#123; //printk("~~~~~~~~~~data = %ld *\n",event); pdata-&gt;online = false; //charge_full_mask=false; power_supply_changed(&amp;pdata-&gt;ac); &#125; pdata-&gt;old_online = pdata-&gt;online; pdata-&gt;old_ac_or_usb = pdata-&gt;ac_or_usb; //printk("~~~~~~~~~~data = %ld *\n",event); //printk("aw_notifier_callback end ....\n"); return 0;&#125;static int bm_aw3215_debugfs_open(struct inode *node, struct file *file)&#123; return single_open(file, bm_aw3215_debugfs_show, NULL);&#125;static int bm_aw3215_debugfs_show(struct seq_file *s, void *what)&#123;// printk("battery_data-&gt;battery_temperature_vadc = %d\n");// printk("battery_data-&gt;battery_capacity_vadc = %d\n"); return seq_printf(s, "%d,%lld\n", battery_data-&gt;battery_temperature_vadc, battery_data-&gt;battery_capacity_vadc); // temperature vadc,capacity vadc.&#125;static const struct file_operations fops_bm_aw3215_debugfs = &#123; .open = bm_aw3215_debugfs_open, .read = seq_read, .llseek = seq_lseek, .release = single_release,&#125;;static int bm_aw3215_debug_fs_init(void)&#123; battery_data-&gt;bm_aw3215_debugfs = debugfs_create_dir(BM_AW3215_DEBUGFS_DIR, 0); if (!debugfs_create_file(BM_AW3215_DEBUGFS_BATTERY_FILE, S_IFREG | S_IRUGO, battery_data-&gt;bm_aw3215_debugfs, NULL, &amp;fops_bm_aw3215_debugfs))&#123; pr_err("aw3215_charger: %s, init failed.\n", __func__); return -1; &#125; return 0;&#125;static int aw3215_battery_probe(struct platform_device *pdev)&#123; int ret; //struct resource *r; struct aw3215_battery_data *data; struct device_node *np = pdev-&gt;dev.of_node; data = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*data), GFP_KERNEL); if (data == NULL) return -ENOMEM; spin_lock_init(&amp;data-&gt;lock); data-&gt;battery.properties = aw3215_battery_props; data-&gt;battery.num_properties = ARRAY_SIZE(aw3215_battery_props); data-&gt;battery.get_property = aw3215_battery_get_property; data-&gt;battery.name = "battery"; data-&gt;battery.type = POWER_SUPPLY_TYPE_BATTERY; data-&gt;ac.properties = aw3215_ac_props; data-&gt;ac.num_properties = ARRAY_SIZE(aw3215_ac_props); data-&gt;ac.get_property = aw3215_ac_get_property; data-&gt;ac.name = "ac"; data-&gt;ac.type = POWER_SUPPLY_TYPE_MAINS; if (of_find_property(np, "qcom,chg-vadc", NULL)) &#123; /* early for VADC get, defer probe if needed */ data-&gt;vadc = qpnp_get_vadc(&amp;pdev-&gt;dev, "chg"); if (IS_ERR(data-&gt;vadc)) &#123; ret = PTR_ERR(data-&gt;vadc); if (ret != -EPROBE_DEFER) pr_err("vadc property configured incorrectly\n"); return ret; &#125; &#125; /* chg gpio info */ data-&gt;ctrl_gpio = of_get_named_gpio(np,"mdm9607,battery-ctrl-gpio", 0); if (gpio_is_valid(data-&gt;ctrl_gpio)) &#123; ret = gpio_request(data-&gt;ctrl_gpio, "aw9625_ctrl_gpio"); if (ret &lt; 0) &#123; printk("failed to request GPIO %d, error %d\n",data-&gt;ctrl_gpio, ret); goto exit; &#125; ret = gpio_direction_output(data-&gt;ctrl_gpio, 0); if (ret &lt; 0) &#123; printk("Failed to configure output direction for ctrlGPIO %d, error %d\n",data-&gt;ctrl_gpio, ret); goto exit_gpio; &#125; &#125; data-&gt;stat_gpio = of_get_named_gpio(np,"mdm9607,battery-stat-gpio", 0); if (gpio_is_valid(data-&gt;stat_gpio)) &#123; ret = gpio_request(data-&gt;stat_gpio, "aw9625_stat_gpio"); if (ret &lt; 0) &#123; printk("failed to request GPIO %d, error %d\n",data-&gt;stat_gpio, ret); goto exit_gpio; &#125; ret = gpio_direction_input(data-&gt;stat_gpio); if (ret &lt; 0) &#123; printk("Failed to configure input direction for GPIO %d, error %d\n",data-&gt;stat_gpio, ret); goto exit_stat_gpio; &#125; printk("-----data-&gt;stat_gpio==%d-------\n",gpio_get_value(data-&gt;stat_gpio)); &#125; ret = power_supply_register(&amp;pdev-&gt;dev, &amp;data-&gt;ac); if (ret) &#123; printk("register power supply ac failed \n"); goto exit_gpio; &#125; //printk("register power supply ac success!!!\n"); ret = power_supply_register(&amp;pdev-&gt;dev, &amp;data-&gt;battery); if (ret) &#123; printk("register power supply battery failed \n"); goto exit_supply; &#125; //printk("register power supply battery success!!!\n"); data-&gt;online = false; data-&gt;first = true ; platform_set_drvdata(pdev, data); battery_data = data; INIT_DELAYED_WORK(&amp;data-&gt;volt_adc_work,get_volt_val_func); data-&gt;volt_adc_queue = create_singlethread_workqueue("get_vlotage_value"); queue_delayed_work(data-&gt;volt_adc_queue,&amp;data-&gt;volt_adc_work,12*HZ); data-&gt;aw_notifier.notifier_call = aw_notifier_callback; ret = aw_register_client(&amp;data-&gt;aw_notifier); if (ret) dev_err(&amp;pdev-&gt;dev, "Unable to register aw_notifier: %d\n",ret); if(bm_aw3215_debug_fs_init() &lt; 0) pr_err("aw3215_charger: init debugfs failed.\n"); printk("aw3215 battery init probe is gone .\n"); return 0;exit_supply: power_supply_unregister(&amp;data-&gt;ac); gpio_free(data-&gt;stat_gpio); gpio_free(data-&gt;ctrl_gpio);exit_stat_gpio: if (gpio_is_valid(data-&gt;stat_gpio)) gpio_free(data-&gt;stat_gpio);exit_gpio: if (gpio_is_valid(data-&gt;ctrl_gpio)) gpio_free(data-&gt;ctrl_gpio);exit: kfree(data); return ret ;&#125;static int aw3215_battery_remove(struct platform_device *pdev)&#123; struct aw3215_battery_data *data = platform_get_drvdata(pdev); power_supply_unregister(&amp;data-&gt;battery); power_supply_unregister(&amp;data-&gt;ac); aw_unregister_client(&amp;data-&gt;aw_notifier); del_timer(&amp;data-&gt;timer); if(battery_data-&gt;bm_aw3215_debugfs) debugfs_remove_recursive(battery_data-&gt;bm_aw3215_debugfs); battery_data = NULL; return 0;&#125;static struct of_device_id aw3215_match_table[] = &#123; &#123; .compatible = "awinic,aw3215",&#125;, &#123; &#125;,&#125;;static struct platform_driver aw3215_battery_device = &#123; .probe = aw3215_battery_probe, .remove = aw3215_battery_remove, .driver = &#123; .owner = THIS_MODULE, .name = "aw3215-battery", .of_match_table = aw3215_match_table, &#125;&#125;;module_platform_driver(aw3215_battery_device);/* get battery capacity in percent by battery voltage @bat_vol: voltage in mV @return val:in percent% */static int bat_get_chg_cap_percent(int64_t bat_vol)&#123; static int last_percent = 0; if( bat_vol &lt; 0) bat_vol = 0; if (bat_vol &gt; r700_chg_bat_voltage[100]) bat_vol = r700_chg_bat_voltage[100]; //calculate percent if( bat_vol &lt; r700_chg_bat_voltage[last_percent]) &#123; while( bat_vol &lt; r700_chg_bat_voltage[last_percent]) last_percent--; &#125; else if( bat_vol &gt;= r700_chg_bat_voltage[last_percent+1]) &#123; last_percent++; while( r700_chg_bat_voltage[last_percent+1] &lt;= bat_vol) &#123; last_percent++; &#125; if(last_percent &gt;= 100) last_percent = 100; &#125; //printk("bat_vol = %lld , r700_chg_bat_voltage = %d\n",bat_vol,last_percent); return last_percent;&#125;static int bat_get_dischg_cap_percent(int64_t bat_vol)&#123; static int last_percent = 0; if( bat_vol &lt; 0) bat_vol = 0; if (bat_vol &gt; r700_dischg_bat_voltage[100]) bat_vol = r700_dischg_bat_voltage[100]; //calculate percent if( bat_vol &lt; r700_dischg_bat_voltage[last_percent]) &#123; while( bat_vol &lt; r700_dischg_bat_voltage[last_percent]) last_percent--; &#125; else if( bat_vol &gt;= r700_dischg_bat_voltage[last_percent+1]) &#123; last_percent++; while( r700_dischg_bat_voltage[last_percent+1] &lt;= bat_vol) &#123; last_percent++; &#125; if(last_percent &gt;= 100) last_percent = 100; &#125; //printk("bat_vol = %lld , r700_dischg_bat_voltage = %d\n",bat_vol,last_percent); return last_percent;&#125;static int64_t batt_avg_adc(int64_t bat_voltage)&#123; int i; int stop = 0; int64_t sum = 0; for (i=0; i&lt;ADC_BUFF_LEN; i++) &#123; if (adc_buff[i] == 0) &#123; adc_buff[i] = bat_voltage; stop = 1; &#125; sum += adc_buff[i]; if (stop) break; &#125; if (i &gt;= ADC_BUFF_LEN-1) &#123; memmove(adc_buff, adc_buff+1, (ADC_BUFF_LEN-1)*sizeof(adc_buff[0])); adc_buff[ADC_BUFF_LEN-1] = 0; &#125; do_div(sum,(i+1)); return sum;&#125;static int batt_avg_percent(int percent)&#123; int i; int stop = 0; int sum = 0; for (i=0; i&lt;PERCENT_BUFF_LEN; i++) &#123; if (percent_buff[i] == 0) &#123; percent_buff[i] = percent; stop = 1; &#125; sum += percent_buff[i]; if (stop) break; &#125; if (i &gt;= PERCENT_BUFF_LEN-1) &#123; memmove(percent_buff, percent_buff+1, (PERCENT_BUFF_LEN-1)*sizeof(percent_buff[0])); percent_buff[PERCENT_BUFF_LEN-1] = 0; &#125; return (sum/(i+1));&#125;MODULE_AUTHOR("hanshuailockwood@android.com");MODULE_LICENSE("GPL");MODULE_DESCRIPTION("Battery driver for the aw3215 emulator");]]></content>
      <categories>
        <category>linux device driver</category>
      </categories>
      <tags>
        <tag>linux device driver</tag>
        <tag>sysfs</tag>
        <tag>debugfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时光小记]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%97%B6%E5%85%89%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[输入密码，查看文章。 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>生活点滴</category>
      </categories>
      <tags>
        <tag>徐桔红</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spi接口的oled显示驱动]]></title>
    <url>%2F2019%2F05%2F24%2Fspi%E6%8E%A5%E5%8F%A3%E7%9A%84oled%E6%98%BE%E7%A4%BA%E9%A9%B1%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[硬件连接图 GPIO配置表 GPIO FUNCTION GPIO_0 SPI_MOSI GPIO_1 SPI_MISO GPIO_2 SPI_CS_N GPIO_3 SPI_CLK GPIO_71 OLED_A0 GPIO_93 OLED_PWR_CTL 设备树配置 代码位置： kernel/arch/arm/boot/dts/qcom/mdm9640.dtsi 123456789101112131415161718192021222324252627282930313233 spi_0: spi@78b5000 &#123; /* BLSP1 QUP1 */ compatible = &quot;qcom,spi-qup-v2&quot;; #address-cells = &lt;1&gt;; #size-cells = &lt;0&gt;; reg-names = &quot;spi_physical&quot;, &quot;spi_bam_physical&quot;; reg = &lt;0x78b5000 0x600&gt;, &lt;0x7884000 0x23000&gt;; interrupt-names = &quot;spi_irq&quot;, &quot;spi_bam_irq&quot;; interrupts = &lt;0 95 0&gt;, &lt;0 238 0&gt;; spi-max-frequency = &lt;19200000&gt;; pinctrl-names = &quot;spi_default&quot;, &quot;spi_sleep&quot;; pinctrl-0 = &lt;&amp;spi0_default &amp;spi0_cs0_active&gt;; pinctrl-1 = &lt;&amp;spi0_sleep &amp;spi0_cs0_sleep&gt;; clocks = &lt;&amp;clock_gcc clk_gcc_blsp1_ahb_clk&gt;, &lt;&amp;clock_gcc clk_gcc_blsp1_qup1_spi_apps_clk&gt;; clock-names = &quot;iface_clk&quot;, &quot;core_clk&quot;; qcom,infinite-mode = &lt;0&gt;; qcom,use-pinctrl; qcom,ver-reg-exists; qcom,master-id = &lt;86&gt;; status = &quot;ok&quot;; qcom-spi-lcd@0 &#123; compatible = &quot;qcom,spi-oled&quot;; reg = &lt;0&gt;; spi-max-frequency = &lt;10000000&gt;; pinctrl-names = &quot;active&quot;, &quot;sleep&quot;; pinctrl-0 = &lt;&amp;oled_rst_active&gt;; pinctrl-1 = &lt;&amp;oled_rst_sleep&gt;; interrupt-parent = &lt;&amp;tlmm_pinmux&gt;; interrupts = &lt;0 0&gt;; qcom_spi_oled,irq-gpio = &lt;&amp;tlmm_pinmux 94 0x00&gt;; &#125;; &#125;; 驱动流程驱动与设备匹配1234567891011121314151617//SPI Driver Info static struct spi_driver spi_oled_driver = &#123; .driver = &#123; .name = "qcom,spi-oled", .owner = THIS_MODULE, .of_match_table = qcom_spi_oled_table, &#125;, .probe = spi_oled_probe, &#125;; static int __init spi_oled_init(void) &#123; return spi_register_driver(&amp;spi_oled_driver); &#125; static void __exit spi_oled_exit(void) &#123; spi_unregister_driver(&amp;spi_oled_driver); &#125; probe函数 probe函数中主要功能就是解析设备树，cs、irq、cpha、cpol等状态，以及对oled的硬件初始化、 注册framebuffer结构体，设置fb_info的var和fix参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117static int spi_oled_probe(struct spi_device *spi)&#123; int irq_gpio = -1; int irq; int cs; int cpha,cpol,cs_high; unsigned int max_speed; int i,ret; struct page *buffer_page; int page_order; struct fb_info * fbinfo; /*----------------- resource init ---------------------------*/ printk("start spi_oled_probe!\r\n"); oled.dev = &amp;spi-&gt;dev; page_order = ffz(~(OLED_BUFFER_SIZE/PAGE_SIZE)) + 1; fb_buf = (uint8_t *)__get_free_pages(GFP_KERNEL, page_order); for( i = 0;i &lt; (OLED_BUFFER_SIZE/PAGE_SIZE) ; i += PAGE_SIZE) &#123; buffer_page = virt_to_page(fb_buf+i); SetPageReserved(buffer_page); &#125; /** spi work mode **/ if(spi-&gt;dev.of_node)&#123; irq_gpio = of_get_named_gpio_flags(spi-&gt;dev.of_node, "qcom_spi_oled,irq-gpio", 0, NULL); &#125; irq = spi-&gt;irq; cs = spi-&gt;chip_select; cpha = ( spi-&gt;mode &amp; SPI_CPHA ) ? 1:0; cpol = ( spi-&gt;mode &amp; SPI_CPOL ) ? 1:0; cs_high = ( spi-&gt;mode &amp; SPI_CS_HIGH ) ? 1:0; max_speed = spi-&gt;max_speed_hz; printk("gpio [%d] irq [%d] gpio_irq [%d] cs [%x] CPHA[%x] CPOL [%x] CS_HIGH [%x]\n", irq_gpio, irq, gpio_to_irq(irq_gpio), cs, cpha, cpol,cs_high); printk("Max_speed [%d]\n", max_speed ); //Transfer can be done after spi_device structure is created spi-&gt;bits_per_word = 8; /** pin control register remap **/ oled.virt_base = devm_ioremap_nocache(&amp;spi-&gt;dev,TLMM_BASE_ADDR,100 * 0x1000); if( oled.virt_base == NULL) &#123; printk("%s ioremap error !\n",__func__); return -ENOMEM; &#125; init_rwsem(&amp;oled.rg.lock); /*----------------------- pin config -----------------------------*/ oled.gpio_reset = GPIO_OLED_RESET; oled.gpio_switch = GPIO_OLED_CMD_DATA; oled_reset_pin_config(); oled_switch_pin_config(); /*---------------------- lcd chip init ---------------------------*/ sh1106g_hw_reset(); sh1106g_disp_init(); /*--------------------- data transfer test -----------------------*/ sh1106g_disp_pic(PIC01); /*--------------------- framebuffer register ----------------------*/ fbinfo = kzalloc(sizeof(struct fb_info),GFP_KERNEL); if( fbinfo == NULL) &#123; printk("%s fbinfo alloc error !\n",__func__); return -ENOMEM; &#125; fbinfo-&gt;fbops = &amp;oled_fb_ops; fbinfo-&gt;flags = FBINFO_FLAG_DEFAULT; fbinfo-&gt;fix.visual = FB_VISUAL_MONO10; fbinfo-&gt;fix.type = FB_TYPE_PACKED_PIXELS; fbinfo-&gt;fix.capabilities = 0; fbinfo-&gt;fix.smem_start = virt_to_phys(fb_buf); fbinfo-&gt;fix.smem_len = sizeof(fb_buf); fbinfo-&gt;fix.accel = FB_ACCEL_NONE; fbinfo-&gt;var.width = 128; fbinfo-&gt;var.height = 64; fbinfo-&gt;var.xres = 128; fbinfo-&gt;var.yres = 64; fbinfo-&gt;var.xres_virtual= 128; fbinfo-&gt;var.yres_virtual= 64; //fbinfo-&gt;var.left_margin = 20; fbinfo-&gt;var.hsync_len = 128; fbinfo-&gt;var.vsync_len = 64; fbinfo-&gt;var.grayscale = 1; fbinfo-&gt;var.bits_per_pixel = 8; fbinfo-&gt;var.activate = FB_ACTIVATE_NOW; fbinfo-&gt;var.pixclock = 500000; //fbinfo-&gt;var.rotate = FB_ROTATE_CW; fbinfo-&gt;fix.mmio_start = virt_to_phys(fb_buf); fbinfo-&gt;fix.mmio_len = sizeof(fb_buf); fbinfo-&gt;var.red.offset = 0; fbinfo-&gt;var.red.length = fbinfo-&gt;var.bits_per_pixel; fbinfo-&gt;var.green = fbinfo-&gt;var.red; fbinfo-&gt;var.blue = fbinfo-&gt;var.red; fbinfo-&gt;var.vmode = FB_VMODE_NONINTERLACED; fbinfo-&gt;screen_base = fb_buf; fbinfo-&gt;screen_size = sizeof(fb_buf); ret = register_framebuffer(fbinfo); if( ret ) &#123; printk("oled register framebuffer !\r\n"); &#125; //dev_err(&amp;spi-&gt;dev, "SPI sync returned [%d]\n",spi_oled_transfer(spi)); /*--------------------- lcd refresh thread ---------------------*/ for( i = 0; i &lt; 8192 ;i ++ ) &#123; fb_buf[i] = PIC01[i%128+(i/1024*128)]&amp;(1&lt;&lt;(7-((i/128)&amp;7))); &#125; sh1106g_disp_refresh(); oled.disp_status = OLED_DISP_ON;; kthread_run(oled_refresh,NULL,"oled"); printk("oled write ok!\r\n"); return 0;&#125; oled_reset_pin_config1234567891011121314151617181920212223242526272829static int oled_reset_pin_config(void)&#123; int result; /** active state **/ oled.pinctrl = devm_pinctrl_get(oled.dev); if (IS_ERR_OR_NULL(oled.pinctrl)) &#123; dev_err(oled.dev, "Failed to get pin ctrl\n"); return PTR_ERR(oled.pinctrl); &#125; oled.pins_active = pinctrl_lookup_state(oled.pinctrl,"active"); if (IS_ERR_OR_NULL(oled.pins_active)) &#123; dev_err(oled.dev, "Failed to lookup pinctrl active state\n"); return PTR_ERR(oled.pins_active); &#125; oled.pins_sleep = pinctrl_lookup_state(oled.pinctrl,"sleep"); if (IS_ERR_OR_NULL(oled.pins_sleep)) &#123; dev_err(oled.dev, "Failed to lookup pinctrl sleep state\n"); return PTR_ERR(oled.pins_sleep); &#125; result = pinctrl_select_state(oled.pinctrl, oled.pins_active); if (result) &#123; dev_err(oled.dev, "%s: Can not set %s pins\n", __func__, "active"); return -1; &#125; /** output high,no pull,12mA **/ gpio_tlmm_config(oled.gpio_reset,0,GPIO_OUTPUT,GPIO_NO_PULL,GPIO_8MA); return 0;&#125; 这是利用pinctrl子系统来进行状态选择的， sh1106g_hw_reset1234567891011121314/*-------------------------------- lcd operation -------------------------------*/static void sh1106g_hw_reset(void)&#123; /** drive high **/ oled_reset_pin_high(); /** delay **/ udelay(100); /** drive low **/ oled_reset_pin_low(); /** delay **/ udelay(100); /** drive high **/ oled_reset_pin_high();&#125; 这是一个硬件复位，先把reset脚拉低再拉高 sh1106g_disp_init123456789101112131415161718192021222324252627282930/** init oled output mode **/ static void sh1106g_disp_init(void)&#123; sh1106g_write_cmd(0xAE); //Set Display Off sh1106g_write_cmd(0xD5); //display divide ratio/osc. freq. mode sh1106g_write_cmd(0x80); sh1106g_write_cmd(0xA8); //multiplex ration mode:63 sh1106g_write_cmd(0x3F); sh1106g_write_cmd(0xD3); //Set Display Offset sh1106g_write_cmd(0x00); sh1106g_write_cmd(0x40); //Set Display Start Line sh1106g_write_cmd(0xAD); //DC-DC Control Mode Set sh1106g_write_cmd(0x8B); //DC-DC ON/OFF Mode Set 0x8A: external dc-dc 0x8b: internal dc-dc sh1106g_write_cmd(0x32);//Set Pump voltage value sh1106g_write_cmd(0xA1);//Segment Remap sh1106g_write_cmd(0xC8); //Sst COM Output Scan Direction sh1106g_write_cmd(0xDA); //common pads hardware: alternative sh1106g_write_cmd(0x12); sh1106g_write_cmd(0x81);//contrast control sh1106g_write_cmd(CONTRAST); sh1106g_write_cmd(0xD9);//set pre-charge period sh1106g_write_cmd(0x1F); sh1106g_write_cmd(0xDB);//VCOM deselect level mode sh1106g_write_cmd(0x40); sh1106g_write_cmd(0xA4);//Set Entire Display On/Off sh1106g_write_cmd(0xA6);//Set Normal Display sh1106g_write_cmd(0x8D);//Set Charge Pump 0x8D, 0x14 sh1106g_write_cmd(0x14);// sh1106g_write_cmd(0xAF);//Set Display On&#125; fb_ops1234567891011121314151617static struct fb_ops oled_fb_ops =&#123; .owner = THIS_MODULE, .fb_open = oled_fb_open, .fb_release = oled_fb_release, .fb_read = oled_fb_read, .fb_write = oled_fb_write, .fb_mmap = oled_fb_mmap, .fb_set_par = oled_set_par, .fb_blank = oled_blank, .fb_setcolreg = oled_setcolreg, .fb_fillrect = oled_fillrect, .fb_copyarea = oled_copyarea, .fb_check_var = oled_check_var, .fb_imageblit = oled_imageblit, .fb_ioctl = oled_fb_ioctl,&#125;; fb_ops 是对framebuffer的操作接口函数 oled_fb_mmap123456789101112131415161718192021222324252627282930/* perform fb specific mmap */static int oled_fb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)&#123; struct fb_fix_screeninfo *fix = &amp;fbi-&gt;fix; struct oled_mem_region *rg = &amp;oled.rg; unsigned long start; u32 len; int r; oled_get_mem_region(rg); start = fix-&gt;smem_start; len = fix-&gt;smem_len; if( vma-&gt;vm_end - vma-&gt;vm_start &gt; OLED_BUFFER_SIZE) &#123; r = -EINVAL; goto error; &#125; r = remap_pfn_range(vma,vma-&gt;vm_start, virt_to_phys((void*)((unsigned long)fb_buf)) &gt;&gt; PAGE_SHIFT, vma-&gt;vm_end-vma-&gt;vm_start,vma-&gt;vm_flags | PAGE_SHARED); if(r != 0) goto error; /* vm_ops.open won't be called for mmap itself. */ atomic_inc(&amp;rg-&gt;map_count); oled_put_mem_region(rg); return 0;error: oled_put_mem_region(rg); return r;&#125; oled_fb_ioctl123456789101112131415static int oled_fb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)&#123; int ret = 0; switch (cmd) &#123; case FBIO_IOCTL_ON: oled.disp_status = OLED_DISP_ON; break; case FBIO_IOCTL_OFF: oled.disp_status = 0; break; default: ret = -ENOTTY; &#125; return ret;&#125; 总结 提供了ioctl接口来点亮以及关闭oled,上层可以调用响应的ioctl函数。图片的显示利用framebuffer的mmap接口直接映射。避免的数据从用户空间到内核的拷贝。]]></content>
      <categories>
        <category>linux device driver</category>
      </categories>
      <tags>
        <tag>linux device driver</tag>
        <tag>spi</tag>
        <tag>oled</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iperf工具测试指导]]></title>
    <url>%2F2019%2F05%2F23%2Fiperf%E5%B7%A5%E5%85%B7%E6%B5%8B%E8%AF%95%E6%8C%87%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[安装iperf下载iperf 在官网根据系统下载响应的版本 https://iperf.fr/iperf-download.php 解压 将下载的压缩包解压到C:/根目录 ，也可以自己指定目录 测试是否安装成功 进入cmd，输入”cd \”，进入C盘根目录 命令行模式下输入“dir”，查看iperf文件夹是否存在，存在则输入“cd iperf”,进入iperf文件夹。 iperf指令参数介绍 参数 说明 -c iperf -c ip_addr:客户端模式，ip_addr为服务器地址 -i 以秒为单位显示报告间隔，比如：iperf -c 222.35.11.23 -i 2 -u 使用UDP协议，发送UDP数据包，默认使用TCP连接 -w 指定TCP窗口大小，默认是8KB(此参数比较重要，需要针对不同的带宽和时延进行调整) -t 测试时间长，默认10秒，比如：iperf -c 222.35.11.23 -t 5 -n (一般配合UDP协议时使用)指定传输的字节数，比如：iperf -c 222.35.11.23 -n 100000 -P 指定同时进行的TCP/UDP连接数(对于高带宽测速，需要该参数建立多条TCP/UDP连接以测得更准确的速率) -p 指定端口号，比如：iperf -c 222.35.11.23 -p 5555 -b 使用的带宽，用于udp测试中 -s iperf -s :服务器模式 实例 测试一个路由器lan口到wifi的一个吞吐量。 测试环境 两台PC,待测路由器。 PC-A通过网线与待测路由相连得到ip地址：192.168.0.25， PC-B通过待测路由发出的wifi进行连接得到ip地址：192.168.0.35 TCP测试lan -&gt; wifi PC-B(跑服务端)：iperf -s -w2m -i 1 PC-A(跑客户端)：iperf -c 192.168.0.35 -i 1 -t 1200 wifi -&gt;lan PC-A(跑服务器端)：iperf -s -w2m -i 1 PC-B(跑客户端)：iperf -c 192.168.0.25 -i 1 -t 1200 UDP测试lan -&gt; wifi PC-B(跑服务端)：iperf -s -u -i 1 PC-A(跑客户端)：iperf -c 192.168.0.35 -i 1 -t 1200 -b300M wifi -&gt;lan PC-A(跑服务器端)：iperf -s -u -i 1 PC-B(跑客户端)：iperf -c 192.168.0.25 -i 1 -t 1200 -b300M 这个测试的是udp wifi在300M速率下的吞吐量情况。我手上的这台mifi产品在300M速率下 tcp：wifi的tx能到150 rx 150 udp：wifi的tx能到156 rx 156 数据仅供参考]]></content>
      <categories>
        <category>工具和软件</category>
      </categories>
      <tags>
        <tag>iperf</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[the_girl]]></title>
    <url>%2F2019%2F05%2F22%2Fthe-girl%2F</url>
    <content type="text"><![CDATA[输入密码，查看文章。 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>生活点滴</category>
      </categories>
      <tags>
        <tag>徐桔红</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[按摩椅项目]]></title>
    <url>%2F2019%2F05%2F14%2F%E6%8C%89%E6%91%A9%E6%A4%85%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[原理 此按摩椅由四部分组成： 按摩椅硬件 单片机（后续文章中以U表示） 4G模块（后续文章中以M表示） 阿里云服务器（后续文章中以S表示） 单片机的功能主要是控制按摩椅操作，比如力度，手法等。使用串口与4G模块通讯。 4G模块的功能主要是与服务器进行通讯，接收服务器指令，通过串口下发指令到下位机 硬件接口 数据通信格式单片机-&gt;4G模块指令概括 SOI(1)+ACK/CMD(1)+PARAMETER(10)+EOI(1) 解析： SOI:开始字节，固定为0X7E CMD:(0x00：获取设备运行状态，0x01:零重力，0x02:升降调节，0x03:气压档位调节)，0x04:背部按摩力度 PARAMETER 参数 EOI:结束字节， 固定为0X5A ACK:应答最高2位表示用户单片机对命令的执行结果：00：执行成功 01：命令错误 10：参数错误 11：其它错误低6位的值与接收到的CMD值相等。 具体通信协议 功能 方向 SOI CMD P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 EOI 获取设备运行状态 M-&gt;U 7E 0 0 0 0 0 0 0 0 0 0 0 5A 设备运行状态响应 U-&gt;M 7E 0 TI T2 气压（1-10） 按摩力度（1-10） 零重力（0-3） 背部升降（0-2） 腿部升降（0-2） 按摩状态（0-2） 有人检测（0-1） 设备音量（0-10） 5A 零重力 M-&gt;U 7E 01 0-3 0 0 0 0 0 0 0 0 0 5A 升降调节 M-&gt;U 7E 02 0-3 0 0 0 0 0 0 0 0 0 5A 气压 M-&gt;U 7E 03 1-10 0 0 0 0 0 0 0 0 0 5A 按摩力度 M-&gt;U 7E 04 1-10 0 0 0 0 0 0 0 0 0 5A 4G模块-&gt;服务器指令概括 代码中封装了一个结构体，作为一个MSG在两者之间传输。 123456struct uart_msg&#123; int type; //类型 int hex_no; //指令编号 int value; // 指令数值 int data; //每条指令的调节，比如按摩力度的各种档位&#125;; 具体通信协议 指令 type no value data 描述 授权指令 1 100 100 \ 指令1为授权指令，时间为value 重启指令 2 0 0 \ 指令2为重启指令，no和value无效 暂停/启动 3 0 0/1 \ 指令3为暂停启动指令，value为1时暂停，为0时启动 心跳包 102 0 xx \ 第一个x表示椅子是否在动，第二个x表示椅子上是否有人 零重力指令 999 0 2 0-3 零重力角度0-3 升降调节 999 0 3 0-3 背部以及腿部调节0-3 气压调节 999 0 4 1-10 数值越大，力度越强 背部摩擦 999 0 5 1-10 数值越大，力度越强 音量调节 999 0 6 0-10 数值越大，音量越大 按摩手法 999 0 7 1-10 表示不同手法 代码简述 代码从阿里云sdk/examples/linux/mqtt/demo.c开始 123456789101112131415161718192021enum &#123; TYPE_SERVER_CTL = 1, //请求授权 TYPE_SERVER_CMD_REBOOT = 2, //重启 TYPE_SERVER_START_OR_PAUSE = 3, //开启或暂停 TYPE_CLIENT_CTL_RESPONED = 101, TYPE_CLIENT_HEARTBEAT = 102, TYPE_CLIENT_READY = 103, TYPE_SERVER_OPERATE = 999, //新增第三方指令集&#125;;//第三方功能集（服务器-&gt;模块）ser_msg.valueenum &#123; ZERO_GRAVITY = 2, //零重力 ELEVATING_REGULATION = 3, //升降调节 BAROMETRIC_GEAR_REGULATION = 4, //气压档位调节 BACK_MASSAGE_STRENRTH = 5, //背部按摩调节 REMOTE_VOLUME_CONTROL = 6, //音量调节 MASSAGE_TECHNIQUE = 7, //按摩手法// REMOTE_VOICE_SWITCH = 8, //远程语音播放内容 上述为定义的指令集 messageArrived函数 服务器与4G模块的通讯函数是massageArived函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/********************************************************************** * 接收消息的回调函数 * * 说明：当其它设备的消息到达时，此函数将被执行。 * 注意：此回调函数中用户在做业务处理时不要使用耗时操作，否则会阻塞接收通道 **********************************************************************/ //Server -&gt; Client包 ,服务器下发的控制报(重启包/授权包...) static void messageArrived(MessageData *md) &#123; //接收消息缓存 char msg[MSG_LEN_MAX] = &#123;0&#125;; struct uart_msg ser_msg; struct uart_msg respond_msg; //发送第三方操作指令调用 char cmd[11] = &#123;0&#125;; char parm[AMY_PARM_LEN] = &#123;0&#125;; int status = -1; MQTTMessage *message = md-&gt;message; if(message-&gt;payloadlen &gt; MSG_LEN_MAX - 1) &#123; printf("process part of receive message\n"); message-&gt;payloadlen = MSG_LEN_MAX - 1; &#125; //复制接收消息到本地缓存 memcpy(msg,message-&gt;payload,message-&gt;payloadlen); //to-do此处可以增加用户自己业务逻辑，例如：开关灯等操作 //打印接收消息 IOT_LOG("###################################\n"); IOT_LOG("subscribe Message: [%s]\n", msg); IOT_LOG("###################################\n"); if (parse_server_message(msg, &amp;ser_msg) != TRUE_IOT) &#123; printf("subscribe Message: not a valied uart cmd or data messages, ignore this\n"); return; &#125; //授权指令，value有效，data无效 else if (ser_msg.type == TYPE_SERVER_CTL) &#123; printf("subscribe Message: authorization or not\n"); respond_msg.type = TYPE_CLIENT_CTL_RESPONED; //respond_msg.hex_no = 0x100; respond_msg.hex_no = ser_msg.hex_no; respond_msg.value = 0; //1: process successful, 0:process failed. if (uart_ctl_trans(uart_fd, ser_msg.value) &gt;= 0) &#123; respond_msg.value = 1; &#125; pub_uart_msg(&amp;client, &amp;respond_msg); &#125; //暂停与继续指令 else if(ser_msg.type == TYPE_SERVER_START_OR_PAUSE) &#123; printf("subscribe Message: start or pause!\n"); cmd[0] = 0x07; cmd[1] = ser_msg.value; status = uart_data_trans(uart_fd, cmd, parm); if (status &lt; 0) &#123; IOT_LOG("Third-party directives send error: please check!\n"); return ; &#125; &#125; //第三方指令 else if(ser_msg.type == TYPE_SERVER_OPERATE) &#123; printf("Operate Message: ser_msg.value = %d,ser_msg.hex_no = %d,ser_msg.data = %d\n", ser_msg.value,ser_msg.hex_no,ser_msg.data); //模块到单片机的指令值比服务器到模块的指令少1 //第三方指令2,3,4,5,6,7对应于C-&gt;U:1,2,3,4,5,6 //ZERO_GRAVITY = 2, //零重力 //ELEVATING_REGULATION = 3, //升降调节 //BAROMETRIC_GEAR_REGULATION = 4, //气压档位调节 //BACK_MASSAGE_STRENRTH = 5, //背部按摩调节 //REMOTE_VOLUME_CONTROL = 6, //音量调节 //MASSAGE_TECHNIQUE = 7, //按摩手法 if(ser_msg.value == ZERO_GRAVITY || ser_msg.value == ELEVATING_REGULATION || ser_msg.value == BAROMETRIC_GEAR_REGULATION || ser_msg.value == BACK_MASSAGE_STRENRTH || ser_msg.value == REMOTE_VOLUME_CONTROL || ser_msg.value == MASSAGE_TECHNIQUE) &#123; cmd[0] = ser_msg.value - 1; cmd[1] = ser_msg.data; status = uart_data_trans(uart_fd, cmd, parm); if (status &lt; 0) &#123; IOT_LOG("Third-party directives send error: please check!\n"); return ; &#125; &#125; &#125; &#125; uart_data_trans函数 这里面涉及的就是将服务器发送过来的数据重新封装从串口发送给下位单片机！uart_data_trans()函数: 将数据包发送到单片机 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/************************send to uart len is 24Bytes. = 1+ 22 + 1but parse format like: 0x7E(1)+CMD|ACK(1)+PARM(10)+0x5A(1) = 13Bytes**************************/int uart_data_trans(int fd, char *cmd, char* out)&#123; int ret = 0; char command = 0; char ack = 0; char buf[UART_DATA_SIZE] = &#123;0&#125;; int i = 0; buf[0] = 0x7E; //SOI buf[UART_DATA_SIZE-1] = 0x5A; //EOI if (fd &lt; 0 || !cmd) return -1; command = cmd[0]; //memcpy(buf+1, cmd, UART_DATA_SIZE-2);//CMD(1Byte) + PARM(10Bytes) for (i =0; i &lt; (UART_DATA_SIZE-2)/2; i++) &#123; buf[1+i*2] = cmd[i] &gt;&gt; 4; buf[1+i*2+1] = cmd[i]&amp;0xf; &#125; ret = uart_send(fd, buf, UART_DATA_SIZE); if (ret &lt; 0) &#123; printf("%s(): uart_send() failed\n" ,__FUNCTION__); return ret; &#125; memset(buf, 0 , UART_DATA_SIZE); ret = uart_recv(fd, buf, UART_DATA_SIZE); if (ret &lt; 0) &#123; printf("%s(): uart_recv() failed\n",__FUNCTION__); return ret; &#125; if (buf[0] != 0x7E || buf[UART_DATA_SIZE-1] != 0x5A) &#123; printf("uart data recv format error: first bytes=0x%02x, end byte=[0x%02x]", buf[0],buf[UART_DATA_SIZE-1]); return -1; &#125; ack = (buf[1]&lt;&lt;4) | (buf[2]&amp;0xf); if ((ack &amp; ACK_CMD_MASK) != command) &#123; printf("uart data ack format error: command =0x%02x, ack cmd =[0x%02x]", command, (ack &amp; ACK_CMD_MASK)); return -1; &#125; if ((ack&gt;&gt;6) != ACK_AMY_SUCCESS) &#123; printf("uart data ack error: [%d(1:cmd err, 2:parm err, 3:other err)]", (ack&gt;&gt;6)); return -1; &#125; ret = 0; for (i =0; i &lt; AMY_PARM_LEN; i++) &#123; out[i] = (buf[3+i*2] &lt;&lt; 4) | (buf[3+i*2+1]&amp;0xf); if (debug) printf("(%02x%02x)[%02x] ",buf[3+i*2], buf[3+i*2+1], out[i]); &#125; if (debug) &#123; printf("\n#########parse parms 20Bytes to 10Byte\n"); &#125; IOT_LOG("%s(): successful, ret=[%d]\n" ,__FUNCTION__, ret); return ret;&#125; 这上面的函数就是发送数据包到单片机 parse_server_message函数 parse_server_message()函数：解析服务器发送过来的原始数据填充到struct uart_msg结构体 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758int parse_server_message(char* msg_buf, struct uart_msg *msg)&#123; if(!msg_buf || !msg) return FALSE_IOT; //"&#123;\"type\":1, \"no\":10, \"value\":\"0\", \"data\":10, \"code\":null&#125;" char *p = NULL; char *dilem = ","; char *remain = NULL; char *src = msg_buf; char *tmp = NULL; char *p2 = NULL; int i = 0; while(NULL != ( p = strtok_r(src, dilem, &amp;remain) )) &#123; //printf("p[%s],remain[%s]\n",p, remain); src = NULL; if ((tmp = strchr(p, ':')) != NULL) &#123; i++; if (strstr(p, "type")) &#123; msg-&gt;type = atoi(tmp+1); &#125; else if (strstr(p, "no")) &#123; msg-&gt;hex_no = strtol(tmp+1, NULL, 16);//hex type &#125; else if (strstr(p, "value")) &#123; if ((p2 = strchr(tmp+1, '\"')) != NULL || (p2 = strchr(tmp+1, '\'')) != NULL) &#123;//value parsed type string. msg-&gt;value = atoi(p2+1); &#125; else &#123;//value parsed type int. msg-&gt;value = atoi(tmp+1); &#125; &#125; else if(strstr(p, "data")) &#123; msg-&gt;data = atoi(tmp+1); &#125; else &#123; //invalid json key i--; &#125; &#125; &#125; if (i &lt; 3) &#123; printf("%s(): Error:lose parameter, i=[%d] less than 3!\n", __FUNCTION__, i); return FALSE_IOT; &#125; IOT_LOG("%s(): parse end:type=[%d], no=[%x], value:[\"%d\"], data:[%x]\n", __FUNCTION__, msg-&gt;type, msg-&gt;hex_no, msg-&gt;value, msg-&gt;data); return TRUE_IOT;&#125; 原始数据是 type:1, no:10, value:0, data:10, code:null 所以以“，”作为分隔，“：”再次分隔可得到相应的数据 总结 本次修改是基于阿里云iot-sdk下运行的，所以关于mqtt代码都是现成的，有兴趣可以查看相关的源码]]></content>
      <categories>
        <category>linux应用</category>
      </categories>
      <tags>
        <tag>mqtt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wlan firmware log]]></title>
    <url>%2F2019%2F05%2F14%2Fwlan-firmware-log%2F</url>
    <content type="text"><![CDATA[修改WCNSS_qcom_cfg.ini 将下面两条词缀全置为1 1234#Enable firmware loggEnablefwlog=1# Enable broadcast logging to the userspace entitiesgMulticastHostFwMsgs=1 确认Data.msc1234//检测ls -al /firmware/image///若没有Data.msc执行以下命令adb push Data.msc /firmware/image/ 更改Data.msc权限1chmod 777 Data.msc 更改linux内核日志级别查询1cat /proc/sys/kernel/printk 更改1echo 4 &gt; /proc/sys/kernel/printk 确认1cat /proc/sys/kernel/printk 打开fw log123iwpriv wlan0 dl_report 1iwpriv wlan0 dl_type 1iwpriv wlan0 dl_loglevel 0 抓取log1cnss_diag -c &gt; /data/fw_log.txt 如果生成的fw_log.txt文件出现如上图所示，说明firmware log已经正常抓取！！]]></content>
      <categories>
        <category>linux调试技巧</category>
      </categories>
      <tags>
        <tag>wifi</tag>
        <tag>firmware log</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[aw9523芯片驱动]]></title>
    <url>%2F2019%2F05%2F11%2Faw9523%E8%8A%AF%E7%89%87%E9%A9%B1%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[硬件连接图 AW9523 是一款 IIC 串口转 16 路 GPIO 并口控制器，8 路 PUSH-PULL 驱动，8 路OPEN-DRAIN 或 PUSH-PULL 驱动可选。芯片上电后，GPIO 口为输出状态，中断使能有效。输出电平状态取决于两位 IIC 地址引脚。AW9523 支持引脚关断功能(PDN)，低有效。重新使能后，内部电路处于默认状态。对每一个输入信号作 8us 去抖动处理，当中断使能时，输入状态变化产生中断请求(INTN)。中断为开漏输出，低有效。通过接口读输入状态寄存器清除中断 芯片介绍寄存器列表 ADDR W/R Default Value(HEX) Function Description 00H R xxH INPUT_PORT0 P0x口输入状态 01H R xxH INPUT_PORT1 P1x 口输入状态 02H W/R xxH OUTPUT_PORT0 P0x口输出驱动逻辑，默认值与i2c地址引脚相关 03H W/R xxH OUTPUT_PORT0 P1x口输出驱动逻辑，默认值与i2c地址引脚相关 04H W/R 00H CFG_PORT0 P0x 口输入或输出选择 05H W/R 00H CFG_PORT1 P1x 口输入或输出选择 06H W/R 00H INTN_PORT0 P0x 口中断使能 07H W/R 00H INTN_PORT1 P1x 口中断使能 08H-10H - - - - 11H W/R 00H GPOMD P0x口选择OPEN-DRAIN驱动或 PUSH-PULL驱动 12H-7EH - - - - 7FH W 00H RESET 写00H复位 GPIO输入输出方向选择 CFG_PORT0 和 CFG_PORT1 设定端口为输入、输出状态。寄存器每一比特对应某个 GPIO端口，该位置’1’代表输入状态，置’0’代表输出状态。AW9523 上电后，默认为输出状态。 GPIO输出驱动 P0x 端口默认为 OPEN-DRAIN 驱动，可通过配置 GPOMD 寄存器设定为 PUSH-PULL 驱动。P1x 端口为 PUSH-PULL 驱动。开漏输出时，通过外部电阻上拉驱动高电平。 GPIO 口默认驱动逻辑取决于 AD0/AD1 两个引脚 AD1 AD0 P17 P16 P15 P14 P13 P12 P11 P10 P07 P06 P05 P04 P03 P02 P01 P00 GND GND 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 GND VCC 0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1 VCC GND 1 1 1 1 0 0 0 0 1 1 1 1 0 0 0 0 VCC VCC 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 GPIO输入状态查询 通过 IIC 接口读 INPUT_PORT0 和 INPUT_PORT1 可获得当前 GPIO 端口逻辑状态。AW9523 GPIO 口支持 1.8V 高电平输入。 中断功能 当 GPIO 口配置成输入状态，且使能中断功能后，该 IO 口的输入状态变化将产生中断请求。默认情况下，16 路 GPIO 口中断使能。AW9523 时刻监测输入状态，当检测到 IO 口逻辑电平变化，内部电路进行 8us 去抖动处理。若 8us 后，确认该状态变化，则中断引脚上电平拉低。 通过读 INPUT_PORT0 和 INPUT_PORT1 寄存器清除中断。由 P0x 变化产生的中断，必须读INPUT_PORT0 寄存器清除；由 P1x 变化产生的中断，必须读 INPUT_PORT1 寄存器清除。不可跨组清除中断。 复位功能 AW9523 支持引脚复位和软复位。拉低 PDN 引脚，AW9523 内部电路处于复位状态直至 PDN引脚拉高。或通过 IIC 接口对 RESET 寄存器写入数据 00H，内部电路也将完成一次复位。 寄存器详细描述INPUT_PORT0(00H) ，输入状态寄存器 位 名称 描述 默认值 D7 INPUT_P07 P07 引脚当前逻辑状态，0-低电平，1-高电平 X D6 INPUT_P06 P06 引脚当前逻辑状态，0-低电平，1-高电平 X D5 INPUT_P05 P05 引脚当前逻辑状态，0-低电平，1-高电平 X D4 INPUT_P04 P04 引脚当前逻辑状态，0-低电平，1-高电平 X D3 INPUT_P03 P03 引脚当前逻辑状态，0-低电平，1-高电平 X D2 INPUT_P02 P02 引脚当前逻辑状态，0-低电平，1-高电平 X D1 INPUT_P01 P01 引脚当前逻辑状态，0-低电平，1-高电平 X D0 INPUT_P00 P00 引脚当前逻辑状态，0-低电平，1-高电平 X INPUT_PORT1(01H)，输入状态寄存器 位 名称 描述 默认值 D7 INPUT_P17 P17 引脚当前逻辑状态，0-低电平，1-高电平 X D6 INPUT_P16 P16 引脚当前逻辑状态，0-低电平，1-高电平 X D5 INPUT_P15 P15 引脚当前逻辑状态，0-低电平，1-高电平 X D4 INPUT_P14 P14 引脚当前逻辑状态，0-低电平，1-高电平 X D3 INPUT_P13 P13 引脚当前逻辑状态，0-低电平，1-高电平 X D2 INPUT_P12 P12 引脚当前逻辑状态，0-低电平，1-高电平 X D1 INPUT_P11 P11 引脚当前逻辑状态，0-低电平，1-高电平 X D0 INPUT_P10 P10 引脚当前逻辑状态，0-低电平，1-高电平 X OUTPUT_PORT0(02H)，输出状态寄存器 AD1/AD0外接GND/GND时，输出默认值 位 名称 描述 默认值 D7 OUTPUT_P07 P07 引脚输出状态，0-低电平，1-高电平 0 D6 OUTPUT_P06 P06 引脚输出状态，0-低电平，1-高电平 0 D5 OUTPUT_P05 P05 引脚输出状态，0-低电平，1-高电平 0 D4 OUTPUT_P04 P04 引脚输出状态，0-低电平，1-高电平 0 D3 OUTPUT_P03 P03 引脚输出状态，0-低电平，1-高电平 0 D2 OUTPUT_P02 P02 引脚输出状态，0-低电平，1-高电平 0 D1 OUTPUT_P01 P01 引脚输出状态，0-低电平，1-高电平 0 D0 OUTPUT_P00 P00 引脚输出状态，0-低电平，1-高电平 0 OUTPUT_PORT1(03H)，输出状态寄存器 AD1/AD0外接GND/GND时，输出默认值 位 名称 描述 默认值 D7 OUTPUT_P17 P17 引脚输出状态，0-低电平，1-高电平 0 D6 OUTPUT_P16 P16 引脚输出状态，0-低电平，1-高电平 0 D5 OUTPUT_P15 P15 引脚输出状态，0-低电平，1-高电平 0 D4 OUTPUT_P14 P14 引脚输出状态，0-低电平，1-高电平 0 D3 OUTPUT_P13 P13 引脚输出状态，0-低电平，1-高电平 0 D2 OUTPUT_P12 P12 引脚输出状态，0-低电平，1-高电平 0 D1 INPUT_P11 P11 引脚输出状态，0-低电平，1-高电平 0 D0 OUTPUT_P10 P10 引脚输出状态，0-低电平，1-高电平 0 INTN_PORT0(06H)，中断使能寄存器 位 名称 描述 默认值 D7 INTN_P07 P07 引脚中断使能控制，0-使能，1-关断 0 D6 INTN_P06 P06 引脚中断使能控制，0-使能，1-关断 0 D5 INTN_P05 P05 引脚中断使能控制，0-使能，1-关断 0 D4 INTN_P04 P04 引脚中断使能控制，0-使能，1-关断 0 D3 INTN_P03 P03 引脚中断使能控制，0-使能，1-关断 0 D2 INTN_P02 P02 引脚中断使能控制，0-使能，1-关断 0 D1 INTN_P01 P01 引脚中断使能控制，0-使能，1-关断 0 D0 INTN_P00 P00 引脚中断使能控制，0-使能，1-关断 0 INTN_PORT1(07H)，中断使能寄存器 位 名称 描述 默认值 D7 INTN_P17 P17 引脚中断使能控制，0-使能，1-关断 0 D6 INTN_P16 P16 引脚中断使能控制，0-使能，1-关断 0 D5 INTN_P15 P15 引脚中断使能控制，0-使能，1-关断 0 D4 INTN_P14 P14 引脚中断使能控制，0-使能，1-关断 0 D3 INTN_P13 P13 引脚中断使能控制，0-使能，1-关断 0 D2 INTN_P12 P12 引脚中断使能控制，0-使能，1-关断 0 D1 INTN_P11 P11 引脚中断使能控制，0-使能，1-关断 0 D0 INTN_P10 P10 引脚中断使能控制，0-使能，1-关断 0 GPIO配置表 AW9523(0x58)主要是用来连接各种灯的 AW9523(0X58) 引脚连接 P00 3G_SIGNAL_LED_B P01 3G_SIGNAL_LED_R P02 3G_SIGNAL_LED_G P03 LED2G4 P04 5GLED P05 LAN LED P06 SIGNAL_LED_1 P07 SIGNAL_LED_2 P14 SIGNAL_LED_3 P15 SIGNAL_LED_4 SCL GPIO11(mdm9x40 i2c_3) SDA GPIO10(mdm9x40 i2c_3) PDN GPIO99(mdm9x40) AW9523(0x5A)主要是用来连接按键的 AW9523(0X5A) 引脚连接 P00 WPS_KEY P01 RESET_KEY SCL GPIO11(mdm9x40 i2c_3) SDA GPIO10(mdm9x40 i2c_3) INTN GPIO94(mdm9x40) PDN GPIO99(mdm9x40) 设备树配置 相关的文件： kernel/arch/arm/boot/dts/qcom/mdm9640.dtsi kernel/arch/arm/boot/dts/qcom/mdm9640-pinctrl.dtsi 12345678910111213141516171819202122232425262728293031323334353637aw9523_pins_rst0: aw9523_pins_rst0 &#123; mux &#123; pins = &quot;gpio99&quot;; function = &quot;gpio&quot;; &#125;; config &#123; pins = &quot;gpio99&quot;; drive-strength = &lt;12&gt;; bias-disable = &lt;0&gt;; output-low; &#125;; &#125;; aw9523_pins_rst1: aw9523_pins_rst1 &#123; mux &#123; pins = &quot;gpio99&quot;; function = &quot;gpio&quot;; &#125;; config &#123; pins = &quot;gpio99&quot;; drive-strength = &lt;12&gt;; bias-disable = &lt;0&gt;; output-high; &#125;; &#125;; aw9523_pins_eint_as_int: aw9523_pins_eint_as_int &#123; mux &#123; pins = &quot;gpio94&quot;; function = &quot;gpio&quot;; &#125;; config &#123; pins = &quot;gpio94&quot;; drive-strength = &lt;10&gt;; input-enable; bias-pull-up; &#125;; &#125;; 1234567891011121314151617181920212223242526&amp;i2c_3 &#123; aw9523_led: aw9523_led@58 &#123; compatible = &quot;awinic,aw9523_led&quot;; reg = &lt;0x58&gt;; reset-gpio = &lt;&amp;tlmm_pinmux 99 0&gt;; status = &quot;okay&quot;; aw9523,led &#123; aw9523,name = &quot;aw9523_led&quot;; aw9523,imax = &lt;3&gt;; aw9523,brightness = &lt;32&gt;; aw9523,max_brightness = &lt;255&gt;; &#125;; &#125;; aw9523_key: aw9523_key@5A &#123; compatible = &quot;awinic,aw9523_key&quot;; reg = &lt;0x5a&gt;; awinic,reset-gpio = &lt;&amp;tlmm_pinmux 99 0&gt;; awinic,irq-gpio = &lt;&amp;tlmm_pinmux 94 0&gt;; pinctrl-names = &quot;aw9523_reset_low&quot;, &quot;aw9523_reset_high&quot;, &quot;aw9523_eint&quot;; pinctrl-0 = &lt;&amp;aw9523_pins_rst0&gt;; pinctrl-1 = &lt;&amp;aw9523_pins_rst1&gt;; pinctrl-2 = &lt;&amp;aw9523_pins_eint_as_int&gt;; status = &quot;okay&quot;; &#125;; &#125;; AW9523驱动流程 相关文件： /kernel/driver/i2c/aw9523/aw9523_key.c /kernel/driver/i2c/aw9523/aw9523_led.c 1234567891011121314151617181920212223242526272829 /* seset &amp; int Pins */ pdata-&gt;pinctrl = devm_pinctrl_get(&amp;client-&gt;dev); if (IS_ERR(pdata-&gt;pinctrl)) &#123; pr_err("%s:failed to get pinctrl\n", __func__); goto err; &#125; pdata-&gt;rst_state_low = pinctrl_lookup_state(pdata-&gt;pinctrl, "aw9523_reset_low"); if (IS_ERR(pdata-&gt;rst_state_low)) &#123; pr_err("%s:can not get reset pinstate\n", __func__); goto err; &#125; pdata-&gt;rst_state_high = pinctrl_lookup_state(pdata-&gt;pinctrl, "aw9523_reset_high"); if (IS_ERR(pdata-&gt;rst_state_high)) &#123; pr_err("%s:can not get reset pinstate\n", __func__); goto err; &#125; pdata-&gt;irq_state = pinctrl_lookup_state(pdata-&gt;pinctrl, "aw9523_eint"); if (IS_ERR(pdata-&gt;irq_state)) &#123; pr_err("%s:can not get irq pinstate\n", __func__); goto err; &#125;ret= pinctrl_select_state(pdata-&gt;pinctrl, pdata-&gt;rst_state_high); if (ret)&#123; pr_err("%s:set reset pin state failed!\n", __func__); &#125;ret = pinctrl_select_state(pdata-&gt;pinctrl, pdata-&gt;irq_state); if (ret)&#123; pr_err("%s:set irq pin state failed!\n", __func__); &#125; pinctrl子系统，选择rst引脚状态 12345678910111213141516171819 /* key report */ pdata-&gt;input = input_allocate_device(); if (!pdata-&gt;input) &#123; dev_err(&amp;client-&gt;dev, "%s: failed to allocate input device\n", __func__); goto err_rst_gpio; &#125;pdata-&gt;input-&gt;name = "aw9523-key"; pdata-&gt;input-&gt;phys = "aw9523-keys/input0"; pdata-&gt;input-&gt;dev.parent = &amp;client-&gt;dev; pdata-&gt;keymap_len = sizeof(key_map)/sizeof(struct keymap); pdata-&gt;keymap = (struct keymap *)&amp;key_map;input_set_drvdata(pdata-&gt;input, pdata);__set_bit(EV_KEY, pdata-&gt;input-&gt;evbit); __set_bit(EV_SYN, pdata-&gt;input-&gt;evbit);for (i = 0; i &lt; pdata-&gt;keymap_len; i++)&#123; if(pdata-&gt;keymap[i].name[0]=='\0') continue; __set_bit(pdata-&gt;keymap[i].key_code, pdata-&gt;input-&gt;keybit); &#125;ret = input_register_device(pdata-&gt;input); 注册input子系统 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729/* * aw9523.c aw9523 martix key * * Version: v1.0.1 * * Copyright (c) 2017 AWINIC Technology CO., LTD * * Author: Nick Li &lt;liweilei@awinic.com.cn&gt; * * This program is free software; you can redistribute it and/or modify it * under the terms of the GNU General Public License as published by the * Free Software Foundation; either version 2 of the License, or (at your * option) any later version. */#include &lt;linux/module.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/interrupt.h&gt;#include &lt;linux/irq.h&gt;#include &lt;linux/workqueue.h&gt;#include &lt;linux/errno.h&gt;#include &lt;linux/pm.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/input.h&gt;#include &lt;linux/i2c.h&gt;#include &lt;linux/gpio.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/wait.h&gt;#include &lt;linux/time.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/of_gpio.h&gt;#include &lt;linux/pinctrl/consumer.h&gt;#include &lt;linux/regulator/consumer.h&gt;#include &lt;linux/dma-mapping.h&gt;#include &lt;linux/hrtimer.h&gt; #include &lt;linux/input/aw9523_key.h&gt;#include &lt;linux/uaccess.h&gt;#define HRTIMER_FRAME 20#define DISABLE_PO_IRQ 0xff#define DISABLE_P1_IRQ 0xff#define ENABLE_PO_IRQ 0xfc#define ENABLE_P1_IRQ 0xff#define P0_IRQ_INPUT_MODE 0x03#define P1_IRQ_INPUT_MODE 0x00/*register list */#define P0_INPUT 0x00#define P1_INPUT 0x01#define P0_OUTPUT 0x02#define P1_OUTPUT 0x03#define P0_CONFIG 0x04#define P1_CONFIG 0x05#define P0_INT 0x06#define P1_INT 0x07#define ID_REG 0x10#define CTL_REG 0x11#define P0_LED_MODE 0x12#define P1_LED_MODE 0x13#define P1_0_DIM0 0x20#define P1_1_DIM0 0x21#define P1_2_DIM0 0x22#define P1_3_DIM0 0x23#define P0_0_DIM0 0x24#define P0_1_DIM0 0x25#define P0_2_DIM0 0x26#define P0_3_DIM0 0x27#define P0_4_DIM0 0x28#define P0_5_DIM0 0x29#define P0_6_DIM0 0x2A#define P0_7_DIM0 0x2B#define P1_4_DIM0 0x2C#define P1_5_DIM0 0x2D#define P1_6_DIM0 0x2E#define P1_7_DIM0 0x2F#define SW_RSTN 0x7F#define KROW_P0_0 0#define KROW_P0_1 1#define KROW_P0_2 2#define KROW_P0_3 3#define KROW_P0_4 4#define KROW_P0_5 5#define KROW_P0_6 6#define KROW_P0_7 7#define KROW_P1_0 8#define KROW_P1_1 9#define KROW_P1_2 10#define KROW_P1_3 11#define KROW_P1_4 12#define KROW_P1_5 13#define KROW_P1_6 14#define KROW_P1_7 15#define SPI_DEV_NAME "si3217x"#define WPSKEY_CODE 293#define RESETKEY_CODE 294struct keymap key_map[16]=&#123; [KROW_P0_0] = &#123;"WPS_KEY", WPSKEY_CODE&#125;, [KROW_P0_1] = &#123;"RESET_KEY", RESETKEY_CODE&#125;,&#125;;static unsigned char keyst_old[2];static unsigned char keyst_def[2] = &#123;0x00, 0x81&#125;;static struct aw9523_kpad_platform_data *aw9523_data = NULL;/********************************************************* * * aw9523 i2c write/read * ********************************************************/static int __aw9523_read_reg(struct i2c_client *client, int reg, unsigned char *val)&#123; int ret; ret = i2c_smbus_read_byte_data(client, reg); if (ret &lt; 0) &#123; dev_err(&amp;client-&gt;dev, "i2c read fail: can't read from %02x: %d\n", reg, ret); return ret; &#125; else &#123; *val = ret; &#125; return 0;&#125;static int __aw9523_write_reg(struct i2c_client *client, int reg, int val)&#123; int ret; ret = i2c_smbus_write_byte_data(client, reg, val); if (ret &lt; 0) &#123; dev_err(&amp;client-&gt;dev, "i2c write fail: can't write %02x to %02x: %d\n", val, reg, ret); return ret; &#125; return 0;&#125;static int aw9523_read_reg(struct i2c_client *client, int reg, unsigned char *val)&#123; int rc; struct aw9523_kpad_platform_data *pdata = NULL; pdata = i2c_get_clientdata(client); if (pdata) &#123; mutex_lock(&amp;pdata-&gt;read_write_lock); rc = __aw9523_read_reg(client, reg, val); mutex_unlock(&amp;pdata-&gt;read_write_lock); &#125; return rc;&#125;static int aw9523_write_reg(struct i2c_client *client, int reg, unsigned char val)&#123; int rc; struct aw9523_kpad_platform_data *pdata; pdata = i2c_get_clientdata(client); mutex_lock(&amp;pdata-&gt;read_write_lock); rc = __aw9523_write_reg(client, reg, val); mutex_unlock(&amp;pdata-&gt;read_write_lock); return rc;&#125;/********************************************************* * * hrtimer work * ********************************************************/static void aw9523_key_work(struct work_struct *work)&#123; struct aw9523_kpad_platform_data *pdata; struct i2c_client *client; unsigned char val; int i; bool key_val; pdata = aw9523_data; client = pdata-&gt;client; aw9523_read_reg(client, P0_INPUT, &amp;val); if(val != keyst_old[0])&#123; for(i = 0; i&lt;8; i++)&#123; if(pdata-&gt;keymap[i].name[0]=='\0') continue; if((val&amp; 1&lt;&lt;i) != (keyst_old[0] &amp; 1&lt;&lt;i))&#123; key_val = ((val&amp; 1&lt;&lt;i) == (keyst_def[0] &amp; 1&lt;&lt;i)); input_report_key(pdata-&gt;input, pdata-&gt;keymap[i].key_code, key_val); &#125; &#125; keyst_old[0] = val; &#125; aw9523_read_reg(client, P1_INPUT, &amp;val); if(val != keyst_old[1])&#123; for(i = 0; i&lt;8; i++)&#123; if(pdata-&gt;keymap[i+8].name[0]=='\0') continue; if((val&amp; 1&lt;&lt;i) != (keyst_old[1] &amp; 1&lt;&lt;i))&#123; key_val = ((val&amp; 1&lt;&lt;i) == (keyst_def[1] &amp; 1&lt;&lt;i)); input_report_key(pdata-&gt;input, pdata-&gt;keymap[i+8].key_code, key_val); &#125; &#125; keyst_old[1] = val; &#125; aw9523_write_reg(client, P0_INT, ENABLE_PO_IRQ); //enable p0 port irq aw9523_write_reg(client, P1_INT, ENABLE_P1_IRQ); //enable p1 port irq input_sync(pdata-&gt;input); enable_irq(client-&gt;irq); return;&#125;static enum hrtimer_restart aw9523_key_timer_func(struct hrtimer *timer)&#123; schedule_work(&amp;aw9523_data-&gt;key_work); return HRTIMER_NORESTART; &#125;/********************************************************* * * int work * ********************************************************/static void aw9523_int_work(struct work_struct *work)&#123; struct aw9523_kpad_platform_data *pdata = container_of(work, struct aw9523_kpad_platform_data, work.work); struct i2c_client *client = pdata-&gt;client; aw9523_write_reg(client, P0_INT, DISABLE_PO_IRQ); //disable p0 port irq aw9523_write_reg(client, P1_INT, DISABLE_P1_IRQ); //disable p1 port irq hrtimer_start(&amp;pdata-&gt;key_timer, ktime_set(0,(1000/HRTIMER_FRAME)*1000000), HRTIMER_MODE_REL);&#125;static irqreturn_t aw9523_irq(int irq, void *handle)&#123; struct i2c_client *client = handle; struct aw9523_kpad_platform_data *pdata; int bm_irq_status = 0; bm_mdm9640_i2c_gpio_read_irq_status(BM_MDM9640_PCIE_WAKE_SET, &amp;bm_irq_status); if (!bm_irq_status) &#123; printk("%s, it is pcie wake irq.\n", __func__); return IRQ_HANDLED; &#125; pdata = i2c_get_clientdata(client); disable_irq_nosync(client-&gt;irq); schedule_delayed_work(&amp;pdata-&gt;work, msecs_to_jiffies(pdata-&gt;delay)); return IRQ_HANDLED;&#125;/********************************************************* * * aw9523 reg * ********************************************************/static ssize_t aw9523_get_reg(struct device* cd,struct device_attribute *attr, char* buf)&#123; unsigned char val = 0; unsigned char i = 0; ssize_t len = 0; struct i2c_client *client = aw9523_data-&gt;client; for(i=0; i&lt;0x30; i++) &#123; aw9523_read_reg(client, i, &amp;val); len += snprintf(buf+len, PAGE_SIZE-len, "reg%2x = 0x%2x, ", i, val); &#125; len += snprintf(buf+len, PAGE_SIZE-len, "\n"); return len;&#125;static ssize_t aw9523_set_reg(struct device* cd, struct device_attribute *attr, const char* buf, size_t len)&#123; unsigned int databuf[2]; struct i2c_client *client = aw9523_data-&gt;client; if(2 == sscanf(buf,"%x %x",&amp;databuf[0], &amp;databuf[1])) &#123; aw9523_write_reg(client,databuf[0], databuf[1]); &#125; return len;&#125;static DEVICE_ATTR(reg, 0660, aw9523_get_reg, aw9523_set_reg);static int aw9523_create_sysfs(struct i2c_client *client)&#123; int err; struct device *dev = &amp;(client-&gt;dev); err = device_create_file(dev, &amp;dev_attr_reg); return err;&#125;static int aw9523_read_chipid(struct i2c_client *client)&#123; unsigned char val; int ret = 0; ret = aw9523_read_reg(client, ID_REG, &amp;val); if(!ret &amp;&amp; val != 0x23) ret = -EINVAL; return ret;&#125;/********************************************************* * * aw9523 init * ********************************************************/static void aw9523_key_init(struct i2c_client *client)&#123; unsigned char val; aw9523_write_reg(client, P0_INT, DISABLE_PO_IRQ); //disable p0 port irq 0x06 aw9523_write_reg(client, P1_INT, DISABLE_P1_IRQ); //disable p1 port irq 0x07 aw9523_write_reg(client, P0_CONFIG, P0_IRQ_INPUT_MODE); //set p0 port input mode 0x04 aw9523_write_reg(client, P1_CONFIG, P1_IRQ_INPUT_MODE); //set p1 port input mode 0x05 aw9523_write_reg(client,P0_LED_MODE, 0xff); aw9523_write_reg(client,P0_LED_MODE, 0xff); aw9523_write_reg(client,CTL_REG, 0x10); aw9523_write_reg(client,P0_OUTPUT, 0x00); aw9523_write_reg(client,P1_OUTPUT, 0x3c); aw9523_read_reg(client, P0_INPUT, &amp;val); keyst_old[0] = val; aw9523_read_reg(client, P1_INPUT, &amp;val); keyst_old[1]= val; aw9523_write_reg(client, P0_INT, ENABLE_PO_IRQ); //enable p0 port irq 0x06 aw9523_write_reg(client, P1_INT, ENABLE_P1_IRQ); //enable p1 port irq 0x07&#125;void bm_mdm9640_i2c_gpio_set(int reg, unsigned char val)&#123; struct i2c_client *client = NULL; unsigned char oldval = 0, setval = 0; int raw_output_port = 0, c_reg; if (!aw9523_data) return ; client = aw9523_data-&gt;client; val = (val &gt; 0 ? 1 : 0); if (reg &gt;= 10) &#123; c_reg = reg - 10; raw_output_port = P1_OUTPUT; &#125; else &#123; c_reg = reg; raw_output_port = P0_OUTPUT; &#125; aw9523_read_reg(client, raw_output_port, &amp;oldval); //printk("%s, read oldval: %02hhx\n", __func__, oldval); setval = oldval; setval &amp;= (~(0x1 &lt;&lt; c_reg)); setval |= (val &lt;&lt; c_reg); //printk("%s, set val: %02hhx, reg:%d, val:%d\n", __func__, setval, reg, val); aw9523_write_reg(client, raw_output_port, setval); return ;&#125;EXPORT_SYMBOL(bm_mdm9640_i2c_gpio_set);void bm_mdm9640_i2c_gpio_irq_set(int reg, unsigned char val)&#123; struct i2c_client *client = NULL; unsigned char oldval = 0, setval = 0; int raw_config_port = 0, raw_int_port = 0, c_reg; if (!aw9523_data) return ; client = aw9523_data-&gt;client; val = (val &gt; 0 ? 1 : 0); if (reg &gt;= 10) &#123; c_reg = reg - 10; raw_config_port = P1_CONFIG; raw_int_port = P1_INT; &#125; else &#123; c_reg = reg; raw_config_port = P0_CONFIG; raw_int_port = P0_INT; &#125; // config input aw9523_read_reg(client, raw_config_port, &amp;oldval); printk("%s, read oldval: %02hhx\n", __func__, oldval); setval = oldval; setval |= (0x1 &lt;&lt; c_reg); printk("%s, set val: %02hhx, reg:%d, val:%d\n", __func__, setval, reg, val); aw9523_write_reg(client, raw_config_port, setval); // config input aw9523_read_reg(client, raw_int_port, &amp;oldval); printk("%s, read int oldval: %02hhx\n", __func__, oldval); setval = oldval; setval &amp;= ~(0x1 &lt;&lt; c_reg); printk("%s, set val: %02hhx, reg:%d, val:%d\n", __func__, setval, reg, val); aw9523_write_reg(client, raw_int_port, setval); return ;&#125;EXPORT_SYMBOL(bm_mdm9640_i2c_gpio_irq_set);void bm_mdm9640_i2c_gpio_read_irq_status(int reg, int *irq_st)&#123; struct i2c_client *client = NULL; unsigned char rval = 0; int raw_input_port = 0, c_reg; if (!aw9523_data) return ; client = aw9523_data-&gt;client; if (reg &gt;= 10) &#123; c_reg = reg - 10; raw_input_port = P1_INPUT; &#125; else &#123; c_reg = reg ; raw_input_port = P0_INPUT; &#125; aw9523_read_reg(client, raw_input_port, &amp;rval); printk("%s, read oldval: %02hhx\n", __func__, rval); *irq_st = ((rval &gt;&gt; c_reg) &amp; 0x01); return ;&#125;EXPORT_SYMBOL(bm_mdm9640_i2c_gpio_read_irq_status);int bm_mdm9640_check_aw9523_ready(void)&#123; if (aw9523_data) return 1; else return 0;&#125;EXPORT_SYMBOL(bm_mdm9640_check_aw9523_ready);#define PANEL_GPIO 8static int get_panel_state(void)&#123; void __iomem * gpio_panel_addr = ioremap_nocache(0x1000000 + PANEL_GPIO * 0x1000, 8); writel(0x01,gpio_panel_addr); return readl(gpio_panel_addr+0x04)&amp;0x01? 1:0;&#125; /********************************************************* * * aw9523 driver * ********************************************************/static int aw9523_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)&#123; struct aw9523_kpad_platform_data *pdata = client-&gt;dev.platform_data; int ret = 0; int i =0; if (!i2c_check_functionality(client-&gt;adapter, I2C_FUNC_SMBUS_BYTE_DATA)) &#123; dev_err(&amp;client-&gt;dev, "SMBUS Byte Data not Supported\n"); return -EIO; &#125; if(!get_panel_state())&#123; dev_err(&amp;client-&gt;dev, "the panel can not use i2c\n"); return -ENOMEM; &#125; pdata = devm_kzalloc(&amp;client-&gt;dev,sizeof(struct aw9523_kpad_platform_data), GFP_KERNEL); if (!pdata) &#123; dev_err(&amp;client-&gt;dev, "Failed to allocate memory\n"); return -ENOMEM; &#125; aw9523_data = pdata; /* seset &amp; int Pins */ pdata-&gt;pinctrl = devm_pinctrl_get(&amp;client-&gt;dev); if (IS_ERR(pdata-&gt;pinctrl)) &#123; pr_err("%s:failed to get pinctrl\n", __func__); goto err; &#125; pdata-&gt;rst_state_low = pinctrl_lookup_state(pdata-&gt;pinctrl, "aw9523_reset_low"); if (IS_ERR(pdata-&gt;rst_state_low)) &#123; pr_err("%s:can not get reset pinstate\n", __func__); goto err; &#125; pdata-&gt;rst_state_high = pinctrl_lookup_state(pdata-&gt;pinctrl, "aw9523_reset_high"); if (IS_ERR(pdata-&gt;rst_state_high)) &#123; pr_err("%s:can not get reset pinstate\n", __func__); goto err; &#125; pdata-&gt;irq_state = pinctrl_lookup_state(pdata-&gt;pinctrl, "aw9523_eint"); if (IS_ERR(pdata-&gt;irq_state)) &#123; pr_err("%s:can not get irq pinstate\n", __func__); goto err; &#125; ret= pinctrl_select_state(pdata-&gt;pinctrl, pdata-&gt;rst_state_high); if (ret)&#123; pr_err("%s:set reset pin state failed!\n", __func__); &#125; ret = pinctrl_select_state(pdata-&gt;pinctrl, pdata-&gt;irq_state); if (ret)&#123; pr_err("%s:set irq pin state failed!\n", __func__); &#125; pdata-&gt;rst_gpio = of_get_named_gpio(client-&gt;dev.of_node, "awinic,reset-gpio", 0); if ((!gpio_is_valid(pdata-&gt;rst_gpio)))&#123; goto err; &#125; ret = gpio_request(pdata-&gt;rst_gpio, "aw9523-reset-keys"); if (ret == 0) &#123; gpio_set_value(pdata-&gt;rst_gpio, 0); msleep(1); gpio_set_value(pdata-&gt;rst_gpio, 1); msleep(1); &#125;else if(ret !=- 16)&#123; dev_err(&amp;client-&gt;dev, "%s: unable to request gpio [%d]\n", __func__, pdata-&gt;rst_gpio); goto err; &#125; /* reset &amp; int Pins end*/ /* hardware reset */ pdata-&gt;client = client; mutex_init(&amp;pdata-&gt;read_write_lock); i2c_set_clientdata(client, pdata); if(aw9523_read_chipid(client)) &#123; dev_err(&amp;client-&gt;dev, "%s: read_chipid error\n", __func__); goto err_rst_gpio; &#125; INIT_DELAYED_WORK(&amp;pdata-&gt;work, aw9523_int_work); pdata-&gt;delay = 10; /* hardware reset end */ /* key report */ pdata-&gt;input = input_allocate_device(); if (!pdata-&gt;input) &#123; dev_err(&amp;client-&gt;dev, "%s: failed to allocate input device\n", __func__); goto err_rst_gpio; &#125; pdata-&gt;input-&gt;name = "aw9523-key"; pdata-&gt;input-&gt;phys = "aw9523-keys/input0"; pdata-&gt;input-&gt;dev.parent = &amp;client-&gt;dev; pdata-&gt;keymap_len = sizeof(key_map)/sizeof(struct keymap); pdata-&gt;keymap = (struct keymap *)&amp;key_map; input_set_drvdata(pdata-&gt;input, pdata); __set_bit(EV_KEY, pdata-&gt;input-&gt;evbit); __set_bit(EV_SYN, pdata-&gt;input-&gt;evbit); for (i = 0; i &lt; pdata-&gt;keymap_len; i++)&#123; if(pdata-&gt;keymap[i].name[0]=='\0') continue; __set_bit(pdata-&gt;keymap[i].key_code, pdata-&gt;input-&gt;keybit); &#125; ret = input_register_device(pdata-&gt;input); if (ret) &#123; dev_err(&amp;client-&gt;dev, "unable to register input device\n"); goto err_free_input; &#125; /* key report end */ /* interrupt work */ pdata-&gt;irq_gpio = of_get_named_gpio(client-&gt;dev.of_node, "awinic,irq-gpio", 0); if ((!gpio_is_valid(pdata-&gt;irq_gpio)))&#123; goto err_free_dev; &#125; ret = gpio_request(pdata-&gt;irq_gpio, "aw9523-keys"); if (ret) &#123; dev_err(&amp;client-&gt;dev, "%s: unable to request gpio [%d]\n", __func__, pdata-&gt;irq_gpio); goto err_free_dev; &#125; ret = gpio_direction_input(pdata-&gt;irq_gpio); if (ret) &#123; dev_err(&amp;client-&gt;dev, "%s: unable to set direction for gpio [%d]\n", __func__, pdata-&gt;irq_gpio); goto err_irq_gpio; &#125; client-&gt;irq = gpio_to_irq(pdata-&gt;irq_gpio); if (client-&gt;irq &lt; 0) &#123; ret = client-&gt;irq; goto err_irq_gpio; &#125; /* hrtimer */ INIT_WORK(&amp;pdata-&gt;key_work, aw9523_key_work); hrtimer_init(&amp;pdata-&gt;key_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); pdata-&gt;key_timer.function = aw9523_key_timer_func; /* hrtimer end */ ret = devm_request_threaded_irq(&amp;client-&gt;dev, client-&gt;irq, NULL, aw9523_irq, IRQF_TRIGGER_LOW | IRQF_ONESHOT | IRQF_SHARED, "aw9523_irq", client); if (ret) &#123; dev_err(&amp;client-&gt;dev, "%s: failed aw9523 irq=%d request ret = %d\n", __func__, client-&gt;irq, ret); goto err_irq_gpio; &#125;else&#123; disable_irq_nosync(client-&gt;irq); &#125; device_init_wakeup(&amp;client-&gt;dev, 1); aw9523_create_sysfs(client); aw9523_key_init(client); enable_irq(client-&gt;irq); pr_err("%s:%d key success\n", __func__,__LINE__); return 0; err_irq_gpio: cancel_work_sync(&amp;pdata-&gt;key_work); gpio_free(pdata-&gt;irq_gpio);err_free_dev: input_unregister_device(pdata-&gt;input);err_free_input: input_free_device(pdata-&gt;input);err_rst_gpio: gpio_free(pdata-&gt;rst_gpio); mutex_destroy(&amp;pdata-&gt;read_write_lock);err: kfree(pdata); aw9523_data = NULL; pr_err("%s:%d key failed\n", __func__,__LINE__); return 0;&#125;static int aw9523_i2c_remove(struct i2c_client *client)&#123; struct aw9523_kpad_platform_data *pdata = i2c_get_clientdata(client); if(!pdata) return -1; aw9523_write_reg(client, 0x00, 0); free_irq(client-&gt;irq, pdata); cancel_delayed_work_sync(&amp;pdata-&gt;work); cancel_work_sync(&amp;pdata-&gt;key_work); gpio_free(pdata-&gt;irq_gpio); input_unregister_device(pdata-&gt;input); input_free_device(pdata-&gt;input); gpio_free(pdata-&gt;rst_gpio); mutex_destroy(&amp;pdata-&gt;read_write_lock); kfree(pdata); aw9523_data = NULL; return 0;&#125;static const struct of_device_id aw9523_keypad_of_match[] = &#123; &#123; .compatible = "awinic,aw9523_key",&#125;, &#123;&#125;,&#125;;static const struct i2c_device_id aw9523_i2c_id[] = &#123; &#123;"aw9523_key", 0&#125;, &#123;&#125;,&#125;;MODULE_DEVICE_TABLE(i2c, aw9523_i2c_id);static struct i2c_driver aw9523_i2c_driver = &#123; .driver = &#123; .name = "aw9523_key", .owner = THIS_MODULE, .of_match_table = aw9523_keypad_of_match, &#125;, .probe = aw9523_i2c_probe, .remove = aw9523_i2c_remove, .id_table = aw9523_i2c_id,&#125;;static int __init aw9523_i2c_init(void)&#123; int ret = 0; ret = i2c_add_driver(&amp;aw9523_i2c_driver); if (ret) &#123; pr_err("fail to add aw9523 device into i2c\n"); return ret; &#125; return 0;&#125;subsys_initcall(aw9523_i2c_init);static void __exit aw9523_i2c_exit(void)&#123; i2c_del_driver(&amp;aw9523_i2c_driver);&#125;module_exit(aw9523_i2c_exit);MODULE_AUTHOR("liweilei@awinic.com.cn");MODULE_DESCRIPTION("AW9523B Keypad driver");MODULE_LICENSE("GPL");]]></content>
      <categories>
        <category>linux device driver</category>
      </categories>
      <tags>
        <tag>i2c driver</tag>
        <tag>linux device driver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[smb358_charger驱动]]></title>
    <url>%2F2019%2F05%2F11%2Fsmb358-charger%E9%A9%B1%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[硬件连接图 下面是该项目所使用的充电芯片smb358的硬件连接图 GPIO引脚配置表 smb引脚 配置说明 SCL GPIO19 SDA GPIO18 EN 高电平使能 STAT MPP02(PMD9607) THERM MPP06(PMD9607) D+ USB D+ D- USB D- USBIN USB_VBUS cpu是通过i2c的通信方式与smb358进行通信。 正常工作时EN上拉成高电平使能。 PMIC通过读取STAT的状态来判断目前的充电状态。 通过读取THERM的ADC值读取温度。 设备树配置 相关的文件： kernel/arch/arm/boot/dts/qcom/mdm9607.dtsi kernel/arch/arm/boot/dts/qcom/mdm9607-pinctrl.dtsi kernel/arch/arm/boot/dts/qcom/mdm9607-mtp.dtsi reg = ; 表示i2c读地址为0x57。 interrupt-parent = &lt;&amp;spmi_bus&gt;; 表示中断控制器为spmi_bus。 interrupts = ; / PMIC MPP 2 / 表示中断为PMIC MPP 2 qcom,float-voltage-mv = ; 饱和充电电压4.2V qcom,fastchg-current-max-ma = ; 最大快充电流1A qcom,irq-gpio = &lt;&amp;pm8019_mpps 2 0&gt;;STAT中断引脚用的是MPP02 qcom,chg-vadc = &lt;&amp;pm8019_vadc&gt;; 测电池电压温度所使用的adc qcom,iterm-ma = ;充电饱和的截止电流（充电结束的标志是充电电流小于100mA） qcom，recharge-mv = ;复冲电压，电压低于饱和电流100mA时，再次充电 smb 驱动流程 相关文件/kernel/driver/power/smb-charger.c 12345678910if (of_find_property(chip-&gt;dev-&gt;of_node, "qcom,chg-vadc", NULL)) &#123; /* early for VADC get, defer probe if needed */ chip-&gt;vadc_dev = qpnp_get_vadc(chip-&gt;dev, "chg"); if (IS_ERR(chip-&gt;vadc_dev)) &#123; rc = PTR_ERR(chip-&gt;vadc_dev); if (rc != -EPROBE_DEFER) pr_err("vadc property configured incorrectly\n"); return rc; &#125;&#125; 解析所使用的adc，通过获取vadc指针，根据不同的通道，可以获取对应的电池电压和电池温度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137static int smb_parse_dt(struct smb358_charger *chip)&#123; int rc; enum of_gpio_flags gpio_flags; struct device_node *node = chip-&gt;dev-&gt;of_node; int batt_present_degree_negative; if (!node) &#123; dev_err(chip-&gt;dev, "device tree info. missing\n"); return -EINVAL; &#125; chip-&gt;charging_disabled = of_property_read_bool(node,"qcom,charger-disabled"); chip-&gt;inhibit_disabled = of_property_read_bool(node, "qcom,chg-inhibit-disabled"); chip-&gt;chg_autonomous_mode = of_property_read_bool(node,"qcom,chg-autonomous-mode"); chip-&gt;disable_apsd = of_property_read_bool(node, "qcom,disable-apsd"); chip-&gt;using_pmic_therm = of_property_read_bool(node,"qcom,using-pmic-therm"); chip-&gt;pmic_vbat_sns = of_property_read_bool(node,"qcom,using-vbat-sns"); chip-&gt;bms_controlled_charging = of_property_read_bool(node,"qcom,bms-controlled-charging"); rc = of_property_read_string(node, "qcom,bms-psy-name",&amp;chip-&gt;bms_psy_name); chip-&gt;chg_valid_gpio = of_get_named_gpio_flags(node,"qcom,chg-valid-gpio", 0, &amp;gpio_flags); if (!gpio_is_valid(chip-&gt;chg_valid_gpio)) dev_dbg(chip-&gt;dev, "Invalid chg-valid-gpio"); else chip-&gt;chg_valid_act_low = gpio_flags &amp; OF_GPIO_ACTIVE_LOW; rc = of_property_read_u32(node, "qcom,fastchg-current-max-ma", &amp;chip-&gt;fastchg_current_max_ma); if (rc) chip-&gt;fastchg_current_max_ma = SMB358_FAST_CHG_MAX_MA; chip-&gt;iterm_disabled = of_property_read_bool(node, "qcom,iterm-disabled"); rc = of_property_read_u32(node, "qcom,iterm-ma", &amp;chip-&gt;iterm_ma); if (rc &lt; 0) chip-&gt;iterm_ma = -EINVAL; rc = of_property_read_u32(node, "qcom,float-voltage-mv", &amp;chip-&gt;vfloat_mv); if (rc &lt; 0) &#123; chip-&gt;vfloat_mv = -EINVAL; pr_err("float-voltage-mv property missing, exit\n"); return -EINVAL; &#125; rc = of_property_read_u32(node, "qcom,recharge-mv", &amp;chip-&gt;recharge_mv); if (rc &lt; 0) chip-&gt;recharge_mv = -EINVAL; chip-&gt;recharge_disabled = of_property_read_bool(node, "qcom,recharge-disabled"); rc = of_property_read_u32(node, "qcom,cold-bat-decidegc", &amp;chip-&gt;cold_bat_decidegc); if (rc &lt; 0) chip-&gt;cold_bat_decidegc = -EINVAL; rc = of_property_read_u32(node, "qcom,hot-bat-decidegc", &amp;chip-&gt;hot_bat_decidegc); if (rc &lt; 0) chip-&gt;hot_bat_decidegc = -EINVAL; rc = of_property_read_u32(node, "qcom,warm-bat-decidegc", &amp;chip-&gt;warm_bat_decidegc); rc |= of_property_read_u32(node, "qcom,cool-bat-decidegc", &amp;chip-&gt;cool_bat_decidegc); if (!rc) &#123; rc = of_property_read_u32(node, "qcom,cool-bat-mv", &amp;chip-&gt;cool_bat_mv); rc |= of_property_read_u32(node, "qcom,warm-bat-mv", &amp;chip-&gt;warm_bat_mv); rc |= of_property_read_u32(node, "qcom,cool-bat-ma", &amp;chip-&gt;cool_bat_ma); rc |= of_property_read_u32(node, "qcom,warm-bat-ma", &amp;chip-&gt;warm_bat_ma); if (rc) chip-&gt;jeita_supported = false; else chip-&gt;jeita_supported = true; &#125; pr_debug("jeita_supported = %d", chip-&gt;jeita_supported); rc = of_property_read_u32(node, "qcom,bat-present-decidegc", &amp;batt_present_degree_negative); if (rc &lt; 0) chip-&gt;bat_present_decidegc = -EINVAL; else chip-&gt;bat_present_decidegc = -batt_present_degree_negative; if (of_get_property(node, "qcom,vcc-i2c-supply", NULL)) &#123; chip-&gt;vcc_i2c = devm_regulator_get(chip-&gt;dev, "vcc-i2c"); if (IS_ERR(chip-&gt;vcc_i2c)) &#123; dev_err(chip-&gt;dev, "%s: Failed to get vcc_i2c regulator\n", __func__); return PTR_ERR(chip-&gt;vcc_i2c); &#125; &#125; chip-&gt;skip_usb_suspend_for_fake_battery = of_property_read_bool(node, "qcom,skip-usb-suspend-for-fake-battery"); if (!chip-&gt;skip_usb_suspend_for_fake_battery) &#123; if (!chip-&gt;vadc_dev) &#123; dev_err(chip-&gt;dev, "VADC device not present with usb suspend on fake battery\n"); return -EINVAL; &#125; rc = smb_parse_batt_id(chip); if (rc) &#123; dev_err(chip-&gt;dev, "failed to read batt-id rc=%d\n", rc); return rc; &#125; &#125; pr_debug("inhibit-disabled = %d, recharge-disabled = %d, recharge-mv = %d,", chip-&gt;inhibit_disabled, chip-&gt;recharge_disabled, chip-&gt;recharge_mv); pr_debug("vfloat-mv = %d, iterm-disabled = %d,", chip-&gt;vfloat_mv, chip-&gt;iterm_disabled); pr_debug("fastchg-current = %d, charging-disabled = %d,", chip-&gt;fastchg_current_max_ma, chip-&gt;charging_disabled); pr_debug("disable-apsd = %d bms = %s cold-bat-degree = %d,", chip-&gt;disable_apsd, chip-&gt;bms_psy_name, chip-&gt;cold_bat_decidegc); pr_debug("hot-bat-degree = %d, bat-present-decidegc = %d\n", chip-&gt;hot_bat_decidegc, chip-&gt;bat_present_decidegc); return 0;&#125; smb_parse_dt解析充电芯片功能配置，根据解析出来的结果，选择某些功能是否支持。比如电池温度检测，各种状态下的温度阈值，对应电池状态的限制电流等由于设备树只配置了充电最大电压、电流以及截至电流和复充电压。这里可以打印这些参数解析首付正常。 123456/* probe the device to check if its actually connected */rc = smb358_read_reg(chip, CHG_OTH_CURRENT_CTRL_REG, &amp;reg);if (rc) &#123; pr_err("Failed to detect SMB358, device absent, rc = %d\n", rc); goto err_set_vtg_i2c;&#125; 上面这步操作就是判断充电芯片是否正常，由于芯片没有 reset 功能，所以系统启动的过程芯片自动工作。通过这一步测试 i2c 读写，可以判断芯片的类型是否是 smb853 以及芯片工作状态。 123456789101112131415chip-&gt;batt_psy.name = "battery";chip-&gt;batt_psy.type = POWER_SUPPLY_TYPE_BATTERY;chip-&gt;batt_psy.get_property = smb358_battery_get_property;chip-&gt;batt_psy.set_property = smb358_battery_set_property;chip-&gt;batt_psy.property_is_writeable = smb358_batt_property_is_writeable;chip-&gt;batt_psy.properties = smb358_battery_properties;chip-&gt;batt_psy.num_properties = ARRAY_SIZE(smb358_battery_properties);chip-&gt;batt_psy.external_power_changed = smb358_external_power_changed;chip-&gt;batt_psy.supplied_to = pm_batt_supplied_to;chip-&gt;batt_psy.num_supplicants = ARRAY_SIZE(pm_batt_supplied_to);chip-&gt;resume_completed = true;rc = power_supply_register(chip-&gt;dev, &amp;chip-&gt;batt_psy); power_supply_register()向 power_supply 里添加一个 battery 设备，以及添加设备的信息。smb358_battery_properties 数组内根据我们的需要添加各种电池信息供上层使用，然后在 smb358_battery_get_property，smb358_battery_set_property 中对这些消息进行处理 1234567891011121314151617181920212223242526 if (chip-&gt;using_pmic_therm) &#123; if (!chip-&gt;jeita_supported) &#123; /* add hot/cold temperature monitor */ chip-&gt;adc_param.low_temp = chip-&gt;cold_bat_decidegc; chip-&gt;adc_param.high_temp = chip-&gt;hot_bat_decidegc; &#125; else &#123; chip-&gt;adc_param.low_temp = chip-&gt;cool_bat_decidegc; chip-&gt;adc_param.high_temp = chip-&gt;warm_bat_decidegc; &#125; chip-&gt;adc_param.timer_interval = ADC_MEAS2_INTERVAL_1S; chip-&gt;adc_param.state_request = ADC_TM_HIGH_LOW_THR_ENABLE; chip-&gt;adc_param.btm_ctx = chip; chip-&gt;adc_param.threshold_notification = smb_chg_adc_notification;#ifdef CONFIG_FOR_BROBDMOBI_R700 chip-&gt;adc_param.channel = P_MUX6_1_1;#else chip-&gt;adc_param.channel = LR_MUX1_BATT_THERM;#endif /* update battery missing info in tm_channel_measure*/ rc = qpnp_adc_tm_channel_measure(chip-&gt;adc_tm_dev, &amp;chip-&gt;adc_param); if (rc) pr_err("requesting ADC error %d\n", rc); &#125; probe 中 qpnp_adc_tm_channel_measure 相当于开启一个定时器，循环监控电池温度，根据电池状况，调整最大电流值，各阶段最大电流值需要根据实际情况添加，根据代码中的解析设备树部分添加个参数，另外充放电曲线根据实验室实际测试结果填写从放电数组中 12345678910111213141516171819202122232425262728293031323334353637383940414243static int smb358_battery_get_property(struct power_supply *psy, enum power_supply_property prop, union power_supply_propval *val)&#123; struct smb358_charger *chip = container_of(psy, struct smb358_charger, batt_psy); switch (prop) &#123; case POWER_SUPPLY_PROP_STATUS: val-&gt;intval = smb358_get_prop_batt_status(chip); break; case POWER_SUPPLY_PROP_PRESENT: val-&gt;intval = smb358_get_prop_batt_present(chip); break; case POWER_SUPPLY_PROP_CAPACITY: val-&gt;intval = smb358_get_prop_batt_capacity(chip); break; case POWER_SUPPLY_PROP_CHARGING_ENABLED: val-&gt;intval = !(chip-&gt;charging_disabled_status &amp; USER); break; case POWER_SUPPLY_PROP_CHARGE_TYPE: val-&gt;intval = smb358_get_prop_charge_type(chip); break; case POWER_SUPPLY_PROP_HEALTH: val-&gt;intval = smb358_get_prop_batt_health(chip); break; case POWER_SUPPLY_PROP_TECHNOLOGY: val-&gt;intval = POWER_SUPPLY_TECHNOLOGY_LION; break; case POWER_SUPPLY_PROP_MODEL_NAME: val-&gt;strval = "SMB358"; break; case POWER_SUPPLY_PROP_TEMP: val-&gt;intval = smb358_get_prop_batt_temp(chip); break; case POWER_SUPPLY_PROP_VOLTAGE_NOW: val-&gt;intval = smb358_get_prop_battery_voltage_now(chip); break; default: return -EINVAL; &#125; return 0;&#125; smb358_battery_get_property()函数就是获取各种电池状态（status,present,capacity,health等等），然后上报给上层。 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798179918001801180218031804180518061807180818091810181118121813181418151816181718181819182018211822182318241825182618271828182918301831183218331834183518361837183818391840184118421843184418451846184718481849185018511852185318541855185618571858185918601861186218631864186518661867186818691870187118721873187418751876187718781879188018811882188318841885188618871888188918901891189218931894189518961897189818991900190119021903190419051906190719081909191019111912191319141915191619171918191919201921192219231924192519261927192819291930193119321933193419351936193719381939194019411942194319441945194619471948194919501951195219531954195519561957195819591960196119621963196419651966196719681969197019711972197319741975197619771978197919801981198219831984198519861987198819891990199119921993199419951996199719981999200020012002200320042005200620072008200920102011201220132014201520162017201820192020202120222023202420252026202720282029203020312032203320342035203620372038203920402041204220432044204520462047204820492050205120522053205420552056205720582059206020612062206320642065206620672068206920702071207220732074207520762077207820792080208120822083208420852086208720882089209020912092209320942095209620972098209921002101210221032104210521062107210821092110211121122113211421152116211721182119212021212122212321242125212621272128212921302131213221332134213521362137213821392140214121422143214421452146214721482149215021512152215321542155215621572158215921602161216221632164216521662167216821692170217121722173217421752176217721782179218021812182218321842185218621872188218921902191219221932194219521962197219821992200220122022203220422052206220722082209221022112212221322142215221622172218221922202221222222232224222522262227222822292230223122322233223422352236223722382239224022412242224322442245224622472248224922502251225222532254225522562257225822592260226122622263226422652266226722682269227022712272227322742275227622772278227922802281228222832284228522862287228822892290229122922293229422952296229722982299230023012302230323042305230623072308230923102311231223132314231523162317231823192320232123222323232423252326232723282329233023312332233323342335233623372338233923402341234223432344234523462347234823492350235123522353235423552356235723582359236023612362236323642365236623672368236923702371237223732374237523762377237823792380238123822383238423852386238723882389239023912392239323942395239623972398239924002401240224032404240524062407240824092410241124122413241424152416241724182419242024212422242324242425242624272428242924302431243224332434243524362437243824392440244124422443244424452446244724482449245024512452245324542455245624572458245924602461246224632464246524662467246824692470247124722473247424752476247724782479248024812482248324842485248624872488248924902491249224932494249524962497249824992500250125022503250425052506250725082509251025112512251325142515251625172518251925202521252225232524252525262527252825292530253125322533253425352536253725382539254025412542254325442545254625472548254925502551255225532554255525562557255825592560256125622563256425652566256725682569257025712572257325742575257625772578257925802581258225832584258525862587258825892590259125922593259425952596259725982599260026012602260326042605260626072608260926102611261226132614261526162617261826192620262126222623262426252626262726282629263026312632263326342635263626372638263926402641264226432644264526462647264826492650265126522653265426552656265726582659266026612662266326642665266626672668266926702671267226732674267526762677267826792680268126822683268426852686268726882689269026912692269326942695269626972698269927002701270227032704270527062707270827092710271127122713271427152716271727182719272027212722272327242725272627272728272927302731273227332734273527362737273827392740274127422743274427452746274727482749275027512752275327542755275627572758275927602761276227632764276527662767276827692770277127722773277427752776277727782779278027812782278327842785278627872788278927902791279227932794279527962797279827992800280128022803280428052806280728082809281028112812281328142815281628172818281928202821282228232824282528262827282828292830283128322833283428352836283728382839284028412842284328442845284628472848284928502851285228532854285528562857285828592860286128622863286428652866286728682869287028712872287328742875287628772878287928802881288228832884288528862887288828892890289128922893289428952896289728982899290029012902290329042905290629072908290929102911291229132914291529162917291829192920292129222923292429252926292729282929293029312932293329342935293629372938293929402941294229432944294529462947294829492950295129522953295429552956295729582959296029612962296329642965296629672968296929702971297229732974297529762977297829792980298129822983298429852986298729882989299029912992299329942995299629972998299930003001300230033004300530063007300830093010301130123013301430153016301730183019302030213022302330243025302630273028302930303031303230333034303530363037303830393040304130423043304430453046304730483049305030513052305330543055305630573058305930603061306230633064306530663067306830693070307130723073307430753076307730783079308030813082308330843085308630873088308930903091309230933094309530963097309830993100310131023103310431053106310731083109311031113112311331143115311631173118311931203121312231233124312531263127312831293130313131323133313431353136313731383139314031413142314331443145314631473148314931503151315231533154315531563157315831593160316131623163316431653166316731683169317031713172317331743175317631773178317931803181318231833184318531863187318831893190319131923193319431953196319731983199320032013202320332043205320632073208320932103211321232133214321532163217321832193220322132223223322432253226322732283229323032313232323332343235323632373238323932403241324232433244324532463247324832493250325132523253325432553256325732583259326032613262326332643265326632673268326932703271327232733274327532763277327832793280328132823283328432853286328732883289/* Copyright (c) 2014-2015 The Linux Foundation. All rights reserved. * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License version 2 and * only version 2 as published by the Free Software Foundation. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU General Public License for more details. */#define pr_fmt(fmt) "SMB358 %s: " fmt, __func__#include &lt;linux/i2c.h&gt;#include &lt;linux/debugfs.h&gt;#include &lt;linux/gpio.h&gt;#include &lt;linux/errno.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/interrupt.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/power_supply.h&gt;#include &lt;linux/regulator/of_regulator.h&gt;#include &lt;linux/regulator/machine.h&gt;#include &lt;linux/regulator/consumer.h&gt;#include &lt;linux/regulator/driver.h&gt;#include &lt;linux/of.h&gt;#include &lt;linux/of_gpio.h&gt;#include &lt;linux/mutex.h&gt;#include &lt;linux/qpnp/qpnp-adc.h&gt;#include &lt;linux/reboot.h&gt;#include &lt;bmtfeatures.h&gt;#define CONFIG_FOR_BROBDMOBI_R700#define _SMB358_MASK(BITS, POS) \ ((unsigned char)(((1 &lt;&lt; (BITS)) - 1) &lt;&lt; (POS)))#define SMB358_MASK(LEFT_BIT_POS, RIGHT_BIT_POS) \ _SMB358_MASK((LEFT_BIT_POS) - (RIGHT_BIT_POS) + 1, \ (RIGHT_BIT_POS))/* Config/Control registers */#define CHG_CURRENT_CTRL_REG 0x0#define CHG_OTH_CURRENT_CTRL_REG 0x1#define VARIOUS_FUNC_REG 0x2#define VFLOAT_REG 0x3#define CHG_CTRL_REG 0x4#define STAT_AND_TIMER_CTRL_REG 0x5#define CHG_PIN_EN_CTRL_REG 0x6#define THERM_A_CTRL_REG 0x7#define SYSOK_AND_USB3_REG 0x8#define OTHER_CTRL_REG 0x9#define OTG_TLMN_THERM_REG 0xA#define FAULT_INT_REG 0xC#define STATUS_INT_REG 0xD#define OTG_TLMN_THERM_REG 0xA/* Command registers */#define CMD_A_REG 0x30#define CMD_B_REG 0x31/* IRQ status registers */#define IRQ_A_REG 0x35#define IRQ_B_REG 0x36#define IRQ_C_REG 0x37#define IRQ_D_REG 0x38#define IRQ_E_REG 0x39#define IRQ_F_REG 0x3A/* Status registers */#define STATUS_C_REG 0x3D#define STATUS_D_REG 0x3E#define STATUS_E_REG 0x3F/* Config bits */#define CHG_INHI_EN_MASK BIT(1)#define CHG_INHI_EN_BIT BIT(1)#define CMD_A_CHG_ENABLE_BIT BIT(1)#define CMD_A_VOLATILE_W_PERM_BIT BIT(7)#define CMD_A_CHG_SUSP_EN_BIT BIT(2)#define CMD_A_CHG_SUSP_EN_MASK BIT(2)#define CMD_A_OTG_ENABLE_BIT BIT(4)#define CMD_A_OTG_ENABLE_MASK BIT(4)#define CMD_B_CHG_HC_ENABLE_BIT BIT(0)#define USB3_ENABLE_BIT BIT(5)#define USB3_ENABLE_MASK BIT(5)#define CMD_B_CHG_USB_500_900_ENABLE_BIT BIT(1)#define CHG_CTRL_AUTO_RECHARGE_ENABLE_BIT 0x0#define CHG_CTRL_CURR_TERM_END_CHG_BIT 0x0//#define CHG_CTRL_BATT_MISSING_DET_THERM_IO SMB358_MASK(5, 4)#define CHG_CTRL_BATT_MISSING_DET_THERM_IO 0#define CHG_CTRL_AUTO_RECHARGE_MASK BIT(7)#define CHG_AUTO_RECHARGE_DIS_BIT BIT(7)#define CHG_CTRL_CURR_TERM_END_MASK BIT(6)#define CHG_CTRL_BATT_MISSING_DET_MASK SMB358_MASK(1, 0)#define CHG_CTRL_BATT_MISSING_DET_MASK1 SMB358_MASK(5, 4)#define CHG_CTRL_APSD_EN_BIT BIT(2)#define CHG_CTRL_APSD_EN_MASK BIT(2)#define CHG_ITERM_MASK 0x07#define CHG_PIN_CTRL_USBCS_REG_BIT 0x0#define CHG_PIN_CTRL_STATE_REG_BIT 0x0/* This is to select if use external pin EN to control CHG */#define CHG_PIN_CTRL_CHG_EN_LOW_PIN_BIT SMB358_MASK(6, 5)#define CHG_PIN_CTRL_CHG_EN_LOW_REG_BIT 0x0#define CHG_PIN_CTRL_CHG_EN_MASK SMB358_MASK(6, 5)#define CHG_LOW_BATT_THRESHOLD \ SMB358_MASK(3, 0)#define CHG_PIN_CTRL_USBCS_REG_MASK BIT(4)#define CHG_PIN_CTRL_STATE_REG_MASK BIT(3)#define CHG_PIN_CTRL_APSD_IRQ_BIT BIT(1)#define CHG_PIN_CTRL_APSD_IRQ_MASK BIT(1)#define CHG_PIN_CTRL_CHG_ERR_IRQ_BIT BIT(2)#define CHG_PIN_CTRL_CHG_ERR_IRQ_MASK BIT(2)#define VARIOUS_FUNC_USB_SUSP_EN_REG_BIT BIT(6)#define VARIOUS_FUNC_USB_SUSP_MASK BIT(6)#define FAULT_INT_HOT_COLD_HARD_BIT BIT(7)#define FAULT_INT_HOT_COLD_SOFT_BIT BIT(6)#define FAULT_INT_INPUT_OV_BIT BIT(3)#define FAULT_INT_INPUT_UV_BIT BIT(2)#define FAULT_INT_AICL_COMPLETE_BIT BIT(1)#define STATUS_INT_CHG_TIMEOUT_BIT BIT(7)#define STATUS_INT_OTG_DETECT_BIT BIT(6)#define STATUS_INT_BATT_OV_BIT BIT(5)#define STATUS_INT_CHGING_BIT BIT(4)#define STATUS_INT_CHG_INHI_BIT BIT(3)#define STATUS_INT_INOK_BIT BIT(2)#define STATUS_INT_MISSING_BATT_BIT BIT(1)#define STATUS_INT_LOW_BATT_BIT BIT(0)#define THERM_A_THERM_MONITOR_EN_BIT BIT(4) #define THERM_A_THERM_MONITOR_EN_MASK BIT(4)#define VFLOAT_MASK 0x3F#define CHG_OTG_CURRENT_LIMIT_REG_BIT BIT(2) // 500mA #define CHG_OTG_CURRENT_LIMIT_REG_MASK BIT(2) /* IRQ status bits */#define IRQ_A_HOT_HARD_BIT BIT(6)#define IRQ_A_COLD_HARD_BIT BIT(4)#define IRQ_A_HOT_SOFT_BIT BIT(2)#define IRQ_A_COLD_SOFT_BIT BIT(0)#define IRQ_B_BATT_MISSING_BIT BIT(4)#define IRQ_B_BATT_LOW_BIT BIT(2)#define IRQ_B_BATT_OV_BIT BIT(6)#define IRQ_B_PRE_FAST_CHG_BIT BIT(0)#define IRQ_C_TAPER_CHG_BIT BIT(2)#define IRQ_C_TERM_BIT BIT(0)#define IRQ_C_INT_OVER_TEMP_BIT BIT(6)#define IRQ_D_CHG_TIMEOUT_BIT (BIT(0) | BIT(2))#define IRQ_D_AICL_DONE_BIT BIT(4)#define IRQ_D_APSD_COMPLETE BIT(6)#define IRQ_E_INPUT_UV_BIT BIT(0)#define IRQ_E_INPUT_OV_BIT BIT(2)#define IRQ_E_AFVC_ACTIVE BIT(4)#define IRQ_F_OTG_VALID_BIT BIT(2)#define IRQ_F_OTG_BATT_FAIL_BIT BIT(4)#define IRQ_F_OTG_OC_BIT BIT(6)#define IRQ_F_POWER_OK BIT(0)/* Status bits */#define STATUS_C_CHARGING_MASK SMB358_MASK(2, 1)#define STATUS_C_FAST_CHARGING BIT(2)#define STATUS_C_PRE_CHARGING BIT(1)#define STATUS_C_TAPER_CHARGING SMB358_MASK(2, 1)#define STATUS_C_CHG_ERR_STATUS_BIT BIT(6)#define STATUS_C_CHG_ENABLE_STATUS_BIT BIT(0)#define STATUS_C_CHG_HOLD_OFF_BIT BIT(3)#define STATUS_D_CHARGING_PORT_MASK \ SMB358_MASK(3, 0)#define STATUS_D_PORT_ACA_DOCK BIT(3)#define STATUS_D_PORT_SDP BIT(2)#define STATUS_D_PORT_DCP BIT(1)#define STATUS_D_PORT_CDP BIT(0)#define STATUS_D_PORT_OTHER SMB358_MASK(1, 0)#define STATUS_D_PORT_ACA_A (BIT(2) | BIT(0))#define STATUS_D_PORT_ACA_B SMB358_MASK(2, 1)#define STATUS_D_PORT_ACA_C SMB358_MASK(2, 0)#define CHG_SYSOK_AND_USB3_HARD_TEMP_LIMITS BIT(2) #define CHG_SYSOK_AND_USB3_HARD_TEMP_LIMITS_MASK BIT(2)/* constants */#define USB2_MIN_CURRENT_MA 100#define USB2_MAX_CURRENT_MA 500#define USB3_MIN_CURRENT_MA 150#define USB3_MAX_CURRENT_MA 900#define AC_CHG_CURRENT_MASK 0x70#define AC_CHG_CURRENT_SHIFT 4#define SMB358_IRQ_REG_COUNT 6#define SMB358_FAST_CHG_MIN_MA 200#define SMB358_FAST_CHG_MAX_MA 2000#define SMB358_FAST_CHG_SHIFT 5#define SMB_FAST_CHG_CURRENT_MASK 0xE0#define SMB358_DEFAULT_BATT_CAPACITY 50#define SMB358_BATT_GOOD_THRE_2P5 0x1#define ADC_BUFF_LEN 100#define PERCENT_BUFF_LEN 100static int adc_buff[ADC_BUFF_LEN] = &#123;0&#125;;static int percent_buff[PERCENT_BUFF_LEN] = &#123;0&#125;;enum &#123; USER = BIT(0), THERMAL = BIT(1), CURRENT = BIT(2), SOC = BIT(3), FAKE_BATTERY = BIT(4),&#125;;struct smb358_regulator &#123; struct regulator_desc rdesc; struct regulator_dev *rdev;&#125;;struct smb358_charger &#123; struct i2c_client *client; struct device *dev; bool inhibit_disabled; bool recharge_disabled; int recharge_mv; bool iterm_disabled; int iterm_ma; int vfloat_mv; int chg_valid_gpio; int chg_valid_act_low; int chg_present; int fake_battery_soc; bool chg_autonomous_mode; bool disable_apsd; bool using_pmic_therm; bool pmic_vbat_sns; bool battery_missing; const char *bms_psy_name; bool resume_completed; bool irq_waiting; bool bms_controlled_charging; bool skip_usb_suspend_for_fake_battery; struct mutex read_write_lock; struct mutex path_suspend_lock; struct mutex irq_complete; u8 irq_cfg_mask[2]; int irq_gpio; int charging_disabled; int fastchg_current_max_ma; unsigned int cool_bat_ma; unsigned int warm_bat_ma; unsigned int cool_bat_mv; unsigned int warm_bat_mv; unsigned int connected_rid; /* debugfs related */#if defined(CONFIG_DEBUG_FS) struct dentry *debug_root; u32 peek_poke_address;#endif /* status tracking */ bool batt_full; bool batt_hot; bool batt_cold; bool batt_warm; bool batt_cool; bool jeita_supported; int charging_disabled_status; int usb_suspended; /* power supply */ struct power_supply *usb_psy; struct power_supply *bms_psy; struct power_supply batt_psy; /* otg 5V regulator */ struct smb358_regulator otg_vreg; /* adc_tm paramters */ struct qpnp_vadc_chip *vadc_dev; struct qpnp_adc_tm_chip *adc_tm_dev; struct qpnp_adc_tm_btm_param adc_param; int cold_bat_decidegc; int hot_bat_decidegc; int cool_bat_decidegc; int warm_bat_decidegc; int bat_present_decidegc; /* i2c pull up regulator */ struct regulator *vcc_i2c;&#125;;struct smb_irq_info &#123; const char *name; int (*smb_irq)(struct smb358_charger *chip, u8 rt_stat); int high; int low;&#125;;struct irq_handler_info &#123; u8 stat_reg; u8 val; u8 prev_val; struct smb_irq_info irq_info[4];&#125;;static int chg_current[] = &#123; 300, 500, 700, 1000, 1200, 1500, 1800, 2000,&#125;;static int fast_chg_current[] = &#123; 200, 450, 600, 900, 1300, 1500, 1800, 2000,&#125;;/* add supplied to "bms" function */static char *pm_batt_supplied_to[] = &#123; "bms",&#125;;//copy from MDM9X25//index is the percent% of battery capacity ,so index 0 is 0, index 101 is +inf//value is in mV//this battery's nominal capacity is:2000mAh,step is 20mAh#ifdef LCD_SECOND_SECHEMEstatic int r700_chg_bat_voltage[102]=&#123; 0, 3452,3466,3480,3494,3508,3522,3536,3550,3564,3578, 3592,3606,3620,3634,3650,3654,3658,3662,3666,3670, 3674,3678,3682,3686,3690,3694,3698,3702,3706,3710, 3714,3718,3722,3726,3730,3734,3738,3742,3746,3750, 3756,3762,3768,3774,3780,3786,3792,3798,3804,3810, 3816,3822,3828,3834,3840,3846,3852,3858,3864,3870, 3829,3836,3844,3850,3900,3912,3924,3936,3948,3960, 3972,3984,3996,4008,4020,4032,4044,4056,4068,4080, 4092,4104,4116,4128,4140,4152,4164,4176,4188,4200, 4206,4212,4218,4224,4230,4236,4242,4248,4254,4260, LONG_MAX&#125;;static int r700_dischg_bat_voltage[102]=&#123; 0, 3314,3328,3342,3356,3370,3384,3398,3412,3424,3438, 3452,3466,3480,3494,3508,3522,3536,3550,3564,3578, 3592,3606,3620,3634,3650,3654,3658,3662,3666,3670, 3674,3678,3682,3686,3690,3694,3698,3702,3706,3710, 3714,3718,3722,3726,3730,3734,3738,3742,3746,3750, 3756,3762,3768,3774,3780,3786,3792,3798,3804,3810, 3816,3822,3828,3834,3840,3846,3852,3858,3864,3870, 3829,3836,3844,3850,3900,3912,3924,3936,3948,3960, 3972,3984,3996,4008,4020,4032,4044,4056,4068,4080, 4092,4104,4116,4128,4140,4152,4164,4176,4188,4200, LONG_MAX&#125;;#else static int r700_chg_bat_voltage[102]=&#123; 0, 3406,3489,3552,3606,3639,3655,3670,3687,3708,3727, 3736,3744,3758,3767,3777,3790,3798,3806,3816,3825, 3831,3839,3845,3848,3850,3855,3856,3857,3860,3862, 3863,3865,3866,3867,3869,3870,3873,3875,3876,3878, 3880,3882,3885,3888,3889,3890,3894,3897,3899,3903, 3905,3909,3914,3919,3923,3927,3929,3934,3938,3943, 3948,3953,3957,3962,3968,3972,3978,3982,3987,3992, 3997,4006,4012,4017,4024,4031,4036,4046,4051,4061, 4065,4075,4084,4090,4100,4109,4118,4129,4138,4149, 4158,4168,4170,4180,4182,4184,4186,4188,4190,4200, LONG_MAX&#125;;static int r700_dischg_bat_voltage[102]=&#123; 0, 3300,3406,3450,3469,3484,3503,3522,3538,3554,3570, 3582,3591,3601,3611,3621,3627,3635,3640,3645,3650, 3655,3660,3662,3665,3670,3670,3675,3675,3678,3679, 3683,3684,3684,3688,3689,3689,3693,3694,3694,3697, 3699,3699,3701,3704,3704,3709,3709,3714,3714,3719, 3723,3724,3728,3733,3738,3743,3748,3750,3754,3761, 3766,3772,3777,3782,3787,3797,3802,3806,3816,3821, 3829,3836,3844,3850,3860,3865,3875,3880,3890,3898, 3904,3914,3923,3929,3938,3948,3958,3968,3978,3987, 3997,4007,4017,4026,4036,4050,4061,4075,4090,4129, LONG_MAX&#125;;#endifstatic int bat_get_chg_cap_percent(int bat_vol);static int bat_get_dischg_cap_percent(int bat_vol);static int batt_avg_percent(int percent);static int batt_avg_adc(int bat_voltage);static int bat_get_chg_cap_percent(int bat_vol)&#123; static int last_percent =0 ; if( bat_vol &lt; 0) bat_vol = 0; if (bat_vol &gt; r700_chg_bat_voltage[100]) bat_vol = r700_chg_bat_voltage[100]; //calculate percent if( bat_vol &lt; r700_chg_bat_voltage[last_percent]) &#123; while( bat_vol &lt; r700_chg_bat_voltage[last_percent]) last_percent--; &#125; else if( bat_vol &gt;= r700_chg_bat_voltage[last_percent+1]) &#123; last_percent++; while( r700_chg_bat_voltage[last_percent+1] &lt;= bat_vol) &#123; last_percent++; &#125; if(last_percent &gt; 99) last_percent = 99; &#125;// printk("bat_vol = %d , r700_chg_bat_voltage = %d\n",bat_vol,last_percent); return last_percent;&#125;static int bat_get_dischg_cap_percent(int bat_vol)&#123; static int last_percent = 0; if( bat_vol &lt; 0) bat_vol = 0; if (bat_vol &gt; r700_dischg_bat_voltage[100]) bat_vol = r700_dischg_bat_voltage[100]; //calculate percent if( bat_vol &lt; r700_dischg_bat_voltage[last_percent]) &#123; while( bat_vol &lt; r700_dischg_bat_voltage[last_percent]) last_percent--; &#125; else if( bat_vol &gt;= r700_dischg_bat_voltage[last_percent+1]) &#123; last_percent++; while( r700_dischg_bat_voltage[last_percent+1] &lt;= bat_vol) &#123; last_percent++; &#125; if(last_percent &gt; 100) last_percent = 100; &#125;// printk("bat_vol = %d , r700_dischg_bat_voltage = %d\n",bat_vol,last_percent); return last_percent;&#125;static int batt_avg_adc(int bat_voltage)&#123; int i; int stop = 0; int sum = 0; for (i=0; i&lt;ADC_BUFF_LEN; i++) &#123; if (adc_buff[i] == 0) &#123; adc_buff[i] = bat_voltage; stop = 1; &#125; sum += adc_buff[i]; if (stop) break; &#125; if (i &gt;= ADC_BUFF_LEN-1) &#123; memmove(adc_buff, adc_buff+1, (ADC_BUFF_LEN-1)*sizeof(adc_buff[0])); adc_buff[ADC_BUFF_LEN-1] = 0; &#125; return (sum/(i+1));&#125;static int batt_avg_percent(int percent)&#123; int i; int stop = 0; int sum = 0; for (i=0; i&lt;PERCENT_BUFF_LEN; i++) &#123; if (percent_buff[i] == 0) &#123; percent_buff[i] = percent; stop = 1; &#125; sum += percent_buff[i]; if (stop) break; &#125; if (i &gt;= PERCENT_BUFF_LEN-1) &#123; memmove(percent_buff, percent_buff+1, (PERCENT_BUFF_LEN-1)*sizeof(percent_buff[0])); percent_buff[PERCENT_BUFF_LEN-1] = 0; &#125; return (sum/(i+1));&#125;static int __smb358_read_reg(struct smb358_charger *chip, u8 reg, u8 *val)&#123; s32 ret; ret = i2c_smbus_read_byte_data(chip-&gt;client, reg); if (ret &lt; 0) &#123; dev_err(chip-&gt;dev, "i2c read fail: can't read from %02x: %d\n", reg, ret); return ret; &#125; else &#123; *val = ret; &#125; return 0;&#125;static int __smb358_write_reg(struct smb358_charger *chip, int reg, u8 val)&#123; s32 ret; ret = i2c_smbus_write_byte_data(chip-&gt;client, reg, val); if (ret &lt; 0) &#123; dev_err(chip-&gt;dev, "i2c write fail: can't write %02x to %02x: %d\n", val, reg, ret); return ret; &#125; return 0;&#125;static int smb358_read_reg(struct smb358_charger *chip, int reg, u8 *val)&#123; int rc; mutex_lock(&amp;chip-&gt;read_write_lock); rc = __smb358_read_reg(chip, reg, val); mutex_unlock(&amp;chip-&gt;read_write_lock); return rc;&#125;static int smb358_write_reg(struct smb358_charger *chip, int reg, u8 val)&#123; int rc; mutex_lock(&amp;chip-&gt;read_write_lock); rc = __smb358_write_reg(chip, reg, val); mutex_unlock(&amp;chip-&gt;read_write_lock); return rc;&#125;static int smb358_masked_write(struct smb358_charger *chip, int reg, u8 mask, u8 val)&#123; s32 rc; u8 temp; mutex_lock(&amp;chip-&gt;read_write_lock); rc = __smb358_read_reg(chip, reg, &amp;temp); if (rc) &#123; dev_err(chip-&gt;dev, "smb358_read_reg Failed: reg=%03X, rc=%d\n", reg, rc); goto out; &#125; temp &amp;= ~mask; temp |= val &amp; mask; rc = __smb358_write_reg(chip, reg, temp); if (rc) &#123; dev_err(chip-&gt;dev, "smb358_write Failed: reg=%03X, rc=%d\n", reg, rc); &#125;out: mutex_unlock(&amp;chip-&gt;read_write_lock); return rc;&#125;static int smb358_enable_volatile_writes(struct smb358_charger *chip)&#123; int rc; rc = smb358_masked_write(chip, CMD_A_REG, CMD_A_VOLATILE_W_PERM_BIT, CMD_A_VOLATILE_W_PERM_BIT); if (rc) dev_err(chip-&gt;dev, "Couldn't write VOLATILE_W_PERM_BIT rc=%d\n", rc); return rc;&#125;static int smb358_fastchg_current_set(struct smb358_charger *chip, unsigned int fastchg_current)&#123; int i; if ((fastchg_current &lt; SMB358_FAST_CHG_MIN_MA) || (fastchg_current &gt; SMB358_FAST_CHG_MAX_MA)) &#123; dev_dbg(chip-&gt;dev, "bad fastchg current mA=%d asked to set\n", fastchg_current); return -EINVAL; &#125; for (i = ARRAY_SIZE(fast_chg_current) - 1; i &gt;= 0; i--) &#123; if (fast_chg_current[i] &lt;= fastchg_current) break; &#125; if (i &lt; 0) &#123; dev_err(chip-&gt;dev, "Invalid current setting %dmA\n", fastchg_current); i = 0; &#125; i = i &lt;&lt; SMB358_FAST_CHG_SHIFT; dev_dbg(chip-&gt;dev, "fastchg limit=%d setting %02x\n", fastchg_current, i); return smb358_masked_write(chip, CHG_CURRENT_CTRL_REG, SMB_FAST_CHG_CURRENT_MASK, i);&#125;#define MIN_FLOAT_MV 3500#define MAX_FLOAT_MV 4500#define VFLOAT_STEP_MV 20#define VFLOAT_4350MV 4350static int smb358_float_voltage_set(struct smb358_charger *chip, int vfloat_mv)&#123; u8 temp; if ((vfloat_mv &lt; MIN_FLOAT_MV) || (vfloat_mv &gt; MAX_FLOAT_MV)) &#123; dev_err(chip-&gt;dev, "bad float voltage mv =%d asked to set\n", vfloat_mv); return -EINVAL; &#125; if (VFLOAT_4350MV == vfloat_mv) temp = 0x2B; else if (vfloat_mv &gt; VFLOAT_4350MV) temp = (vfloat_mv - MIN_FLOAT_MV) / VFLOAT_STEP_MV + 1; else temp = (vfloat_mv - MIN_FLOAT_MV) / VFLOAT_STEP_MV; return smb358_masked_write(chip, VFLOAT_REG, VFLOAT_MASK, temp);&#125;#define CHG_ITERM_30MA 0x00#define CHG_ITERM_40MA 0x01#define CHG_ITERM_60MA 0x02#define CHG_ITERM_80MA 0x03#define CHG_ITERM_100MA 0x04#define CHG_ITERM_125MA 0x05#define CHG_ITERM_150MA 0x06#define CHG_ITERM_200MA 0x07static int smb358_term_current_set(struct smb358_charger *chip)&#123; u8 reg = 0; int rc; if (chip-&gt;iterm_ma != -EINVAL) &#123; if (chip-&gt;iterm_disabled) dev_err(chip-&gt;dev, "Error: Both iterm_disabled and iterm_ma set\n"); if (chip-&gt;iterm_ma &lt;= 30) reg = CHG_ITERM_30MA; else if (chip-&gt;iterm_ma &lt;= 40) reg = CHG_ITERM_40MA; else if (chip-&gt;iterm_ma &lt;= 60) reg = CHG_ITERM_60MA; else if (chip-&gt;iterm_ma &lt;= 80) reg = CHG_ITERM_80MA; else if (chip-&gt;iterm_ma &lt;= 100) reg = CHG_ITERM_100MA; else if (chip-&gt;iterm_ma &lt;= 125) reg = CHG_ITERM_125MA; else if (chip-&gt;iterm_ma &lt;= 150) reg = CHG_ITERM_150MA; else reg = CHG_ITERM_200MA; rc = smb358_masked_write(chip, CHG_CURRENT_CTRL_REG, CHG_ITERM_MASK, reg); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't set iterm rc = %d\n", rc); return rc; &#125; &#125; if (chip-&gt;iterm_disabled) &#123; rc = smb358_masked_write(chip, CHG_CTRL_REG, CHG_CTRL_CURR_TERM_END_MASK, CHG_CTRL_CURR_TERM_END_MASK); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't set iterm rc = %d\n", rc); return rc; &#125; &#125; else &#123; rc = smb358_masked_write(chip, CHG_CTRL_REG, CHG_CTRL_CURR_TERM_END_MASK, 0); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't enable iterm rc = %d\n", rc); return rc; &#125; &#125; return 0;&#125;#define VFLT_300MV 0x0C#define VFLT_200MV 0x08#define VFLT_100MV 0x04#define VFLT_50MV 0x00#define VFLT_MASK 0x0Cstatic int smb358_recharge_and_inhibit_set(struct smb358_charger *chip)&#123; u8 reg = 0; int rc; if (chip-&gt;recharge_disabled) rc = smb358_masked_write(chip, CHG_CTRL_REG, CHG_CTRL_AUTO_RECHARGE_MASK, CHG_AUTO_RECHARGE_DIS_BIT); else rc = smb358_masked_write(chip, CHG_CTRL_REG, CHG_CTRL_AUTO_RECHARGE_MASK, 0x0); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't set auto recharge en reg rc = %d\n", rc); &#125; if (chip-&gt;inhibit_disabled) rc = smb358_masked_write(chip, CHG_OTH_CURRENT_CTRL_REG, CHG_INHI_EN_MASK, 0x0); else rc = smb358_masked_write(chip, CHG_OTH_CURRENT_CTRL_REG, CHG_INHI_EN_MASK, CHG_INHI_EN_BIT); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't set inhibit en reg rc = %d\n", rc); &#125; if (chip-&gt;recharge_mv != -EINVAL) &#123; if (chip-&gt;recharge_mv &lt;= 50) reg = VFLT_50MV; else if (chip-&gt;recharge_mv &lt;= 100) reg = VFLT_100MV; else if (chip-&gt;recharge_mv &lt;= 200) reg = VFLT_200MV; else reg = VFLT_300MV; rc = smb358_masked_write(chip, CHG_OTH_CURRENT_CTRL_REG, VFLT_MASK, reg); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't set inhibit threshold rc = %d\n", rc); return rc; &#125; &#125; return 0;&#125;static int smb358_chg_otg_regulator_enable(struct regulator_dev *rdev)&#123; int rc = 0; struct smb358_charger *chip = rdev_get_drvdata(rdev); rc = smb358_masked_write(chip, CMD_A_REG, CMD_A_OTG_ENABLE_BIT, CMD_A_OTG_ENABLE_BIT); if (rc) dev_err(chip-&gt;dev, "Couldn't enable OTG mode rc=%d, reg=%2x\n", rc, CMD_A_REG); return rc;&#125;static int smb358_chg_otg_regulator_disable(struct regulator_dev *rdev)&#123; int rc = 0; struct smb358_charger *chip = rdev_get_drvdata(rdev); rc = smb358_masked_write(chip, CMD_A_REG, CMD_A_OTG_ENABLE_BIT, 0); if (rc) dev_err(chip-&gt;dev, "Couldn't disable OTG mode rc=%d, reg=%2x\n", rc, CMD_A_REG); return rc;&#125;static int smb358_chg_otg_regulator_is_enable(struct regulator_dev *rdev)&#123; int rc = 0; u8 reg = 0; struct smb358_charger *chip = rdev_get_drvdata(rdev); rc = smb358_read_reg(chip, CMD_A_REG, &amp;reg); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't read OTG enable bit rc=%d, reg=%2x\n", rc, CMD_A_REG); return rc; &#125; return (reg &amp; CMD_A_OTG_ENABLE_BIT) ? 1 : 0;&#125;struct regulator_ops smb358_chg_otg_reg_ops = &#123; .enable = smb358_chg_otg_regulator_enable, .disable = smb358_chg_otg_regulator_disable, .is_enabled = smb358_chg_otg_regulator_is_enable,&#125;;static int smb358_regulator_init(struct smb358_charger *chip)&#123; int rc = 0; struct regulator_init_data *init_data; struct regulator_config cfg = &#123;&#125;; init_data = of_get_regulator_init_data(chip-&gt;dev, chip-&gt;dev-&gt;of_node); if (!init_data) &#123; dev_err(chip-&gt;dev, "Allocate memory failed\n"); return -ENOMEM; &#125; /* Give the name, then will register */ if (init_data-&gt;constraints.name) &#123; chip-&gt;otg_vreg.rdesc.owner = THIS_MODULE; chip-&gt;otg_vreg.rdesc.type = REGULATOR_VOLTAGE; chip-&gt;otg_vreg.rdesc.ops = &amp;smb358_chg_otg_reg_ops; chip-&gt;otg_vreg.rdesc.name = init_data-&gt;constraints.name; cfg.dev = chip-&gt;dev; cfg.init_data = init_data; cfg.driver_data = chip; cfg.of_node = chip-&gt;dev-&gt;of_node; init_data-&gt;constraints.valid_ops_mask |= REGULATOR_CHANGE_STATUS; chip-&gt;otg_vreg.rdev = regulator_register( &amp;chip-&gt;otg_vreg.rdesc, &amp;cfg); if (IS_ERR(chip-&gt;otg_vreg.rdev)) &#123; rc = PTR_ERR(chip-&gt;otg_vreg.rdev); chip-&gt;otg_vreg.rdev = NULL; if (rc != -EPROBE_DEFER) dev_err(chip-&gt;dev, "OTG reg failed, rc=%d\n", rc); &#125; &#125; return rc;&#125;static int __smb358_path_suspend(struct smb358_charger *chip, bool suspend)&#123; int rc; rc = smb358_masked_write(chip, CMD_A_REG, CMD_A_CHG_SUSP_EN_MASK, suspend ? CMD_A_CHG_SUSP_EN_BIT : 0); if (rc &lt; 0) dev_err(chip-&gt;dev, "Couldn't set CMD_A reg, rc = %d\n", rc); return rc;&#125;static int smb358_path_suspend(struct smb358_charger *chip, int reason, bool suspend)&#123; int rc = 0; int suspended; mutex_lock(&amp;chip-&gt;path_suspend_lock); suspended = chip-&gt;usb_suspended; if (suspend == false) suspended &amp;= ~reason; else suspended |= reason; if (!chip-&gt;usb_suspended &amp;&amp; suspended) &#123; rc = __smb358_path_suspend(chip, true); chip-&gt;usb_suspended = suspended; power_supply_set_online(chip-&gt;usb_psy, !chip-&gt;usb_suspended); power_supply_changed(chip-&gt;usb_psy); &#125; else if (chip-&gt;usb_suspended &amp;&amp; !suspended) &#123; rc = __smb358_path_suspend(chip, false); chip-&gt;usb_suspended = suspended; power_supply_set_online(chip-&gt;usb_psy, !chip-&gt;usb_suspended); power_supply_changed(chip-&gt;usb_psy); &#125; if (rc) dev_err(chip-&gt;dev, "Couldn't set/unset suspend rc = %d\n", rc); mutex_unlock(&amp;chip-&gt;path_suspend_lock); return rc;&#125;static int __smb358_charging_disable(struct smb358_charger *chip, bool disable)&#123; int rc; rc = smb358_masked_write(chip, CMD_A_REG, CMD_A_CHG_ENABLE_BIT, disable ? 0 : CMD_A_CHG_ENABLE_BIT); if (rc &lt; 0) pr_err("Couldn't set CHG_ENABLE_BIT diable = %d, rc = %d\n", disable, rc); return rc;&#125;static int smb358_charging_disable(struct smb358_charger *chip, int reason, int disable)&#123; int rc = 0; int disabled; disabled = chip-&gt;charging_disabled_status; pr_debug("reason = %d requested_disable = %d disabled_status = %d\n", reason, disable, disabled); if (disable == true) disabled |= reason; else disabled &amp;= ~reason; if (!!disabled == !!chip-&gt;charging_disabled_status) goto skip; rc = __smb358_charging_disable(chip, !!disabled); if (rc) &#123; pr_err("Failed to disable charging rc = %d\n", rc); return rc; &#125; else &#123; /* will not modify online status in this condition */ power_supply_changed(&amp;chip-&gt;batt_psy); &#125;skip: chip-&gt;charging_disabled_status = disabled; return rc;&#125;#define MAX_INV_BATT_ID 7700#define MIN_INV_BATT_ID 7300static int smb358_hw_init(struct smb358_charger *chip)&#123; int rc; u8 reg = 0, mask = 0; /* * If the charger is pre-configured for autonomous operation, * do not apply additonal settings */ if (chip-&gt;chg_autonomous_mode) &#123; dev_dbg(chip-&gt;dev, "Charger configured for autonomous mode\n"); return 0; &#125; rc = smb358_enable_volatile_writes(chip); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't configure volatile writes rc=%d\n", rc); return rc; &#125; /* setup defaults for CHG_CNTRL_REG */ reg = CHG_CTRL_BATT_MISSING_DET_THERM_IO; mask = CHG_CTRL_BATT_MISSING_DET_MASK; rc = smb358_masked_write(chip, CHG_CTRL_REG, mask, reg); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't set CHG_CTRL_REG rc=%d\n", rc); return rc; &#125; //reg = BIT(4) | (~(BIT(5))); mask = CHG_CTRL_BATT_MISSING_DET_MASK1; rc = smb358_masked_write(chip, CHG_CTRL_REG, mask, reg); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't set CHG_CTRL_REG rc=%d\n", rc); return rc; &#125; /* setup charging will not suspend, if battery temperature outside hard limits. */ reg = CHG_SYSOK_AND_USB3_HARD_TEMP_LIMITS; mask = CHG_SYSOK_AND_USB3_HARD_TEMP_LIMITS_MASK; rc = smb358_masked_write(chip, SYSOK_AND_USB3_REG, mask, reg); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't set SYSOK_AND_USB3_REG rc=%d\n", rc); return rc; &#125; /* setup defaults for PIN_CTRL_REG */ if (!chip-&gt;battery_missing) &#123; reg = CHG_PIN_CTRL_USBCS_REG_BIT | CHG_PIN_CTRL_CHG_EN_LOW_REG_BIT | CHG_PIN_CTRL_STATE_REG_BIT | CHG_PIN_CTRL_APSD_IRQ_BIT | CHG_PIN_CTRL_CHG_ERR_IRQ_BIT; mask = CHG_PIN_CTRL_CHG_EN_MASK | CHG_PIN_CTRL_USBCS_REG_MASK | CHG_PIN_CTRL_STATE_REG_MASK | CHG_PIN_CTRL_APSD_IRQ_MASK | CHG_PIN_CTRL_CHG_ERR_IRQ_MASK; rc = smb358_masked_write(chip, CHG_PIN_EN_CTRL_REG, mask, reg); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't set CHG_PIN_EN_CTRL_REG rc=%d\n", rc); return rc; &#125; &#125; /* set otg current limit*/ reg = CHG_OTG_CURRENT_LIMIT_REG_BIT; mask = CHG_OTG_CURRENT_LIMIT_REG_MASK; rc = smb358_masked_write(chip, OTG_TLMN_THERM_REG, mask, reg); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't set CHG_OTG_CURRENT_LIMIT_REG rc=%d\n", rc); return rc; &#125; /* setup USB suspend and APSD */ rc = smb358_masked_write(chip, VARIOUS_FUNC_REG, VARIOUS_FUNC_USB_SUSP_MASK, VARIOUS_FUNC_USB_SUSP_EN_REG_BIT); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't set VARIOUS_FUNC_REG rc=%d\n", rc); return rc; &#125; if (!chip-&gt;disable_apsd) reg = CHG_CTRL_APSD_EN_BIT; else reg = 0; rc = smb358_masked_write(chip, CHG_CTRL_REG, CHG_CTRL_APSD_EN_MASK, reg); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't set CHG_CTRL_REG rc=%d\n", rc); return rc; &#125; /* Fault and Status IRQ configuration */ //reg = FAULT_INT_HOT_COLD_HARD_BIT | FAULT_INT_HOT_COLD_SOFT_BIT reg = FAULT_INT_INPUT_UV_BIT | FAULT_INT_AICL_COMPLETE_BIT | FAULT_INT_INPUT_OV_BIT; rc = smb358_write_reg(chip, FAULT_INT_REG, reg); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't set FAULT_INT_REG rc=%d\n", rc); return rc; &#125; reg = STATUS_INT_CHG_TIMEOUT_BIT | STATUS_INT_OTG_DETECT_BIT | STATUS_INT_BATT_OV_BIT | STATUS_INT_CHGING_BIT | STATUS_INT_CHG_INHI_BIT | STATUS_INT_INOK_BIT | STATUS_INT_LOW_BATT_BIT | STATUS_INT_MISSING_BATT_BIT; rc = smb358_write_reg(chip, STATUS_INT_REG, reg); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't set STATUS_INT_REG rc=%d\n", rc); return rc; &#125; /* setup THERM Monitor */ rc = smb358_masked_write(chip, THERM_A_CTRL_REG, THERM_A_THERM_MONITOR_EN_MASK, THERM_A_THERM_MONITOR_EN_BIT); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't set THERM_A_CTRL_REG rc=%d\n", rc); return rc; &#125; /* set the fast charge current limit */ rc = smb358_fastchg_current_set(chip, chip-&gt;fastchg_current_max_ma); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't set fastchg current rc=%d\n", rc); return rc; &#125; /* set the float voltage */ rc = smb358_float_voltage_set(chip, chip-&gt;vfloat_mv); if (rc &lt; 0) &#123; dev_err(chip-&gt;dev, "Couldn't set float voltage rc = %d\n", rc); return rc; &#125; /* set iterm */ rc = smb358_term_current_set(chip); if (rc) dev_err(chip-&gt;dev, "Couldn't set term current rc=%d\n", rc); /* set recharge */ rc = smb358_recharge_and_inhibit_set(chip); if (rc) dev_err(chip-&gt;dev, "Couldn't set recharge para rc=%d\n", rc); /* suspend USB path for fake battery */ if (!chip-&gt;skip_usb_suspend_for_fake_battery) &#123; if ((chip-&gt;connected_rid &gt;= MIN_INV_BATT_ID) &amp;&amp; (chip-&gt;connected_rid &lt;= MAX_INV_BATT_ID)) &#123; rc = smb358_path_suspend(chip, FAKE_BATTERY, true); if (!rc) dev_info(chip-&gt;dev, "Suspended USB path reason FAKE_BATTERY\n"); &#125; &#125; /* enable/disable charging */ if (chip-&gt;charging_disabled) &#123; rc = smb358_charging_disable(chip, USER, 1); if (rc) dev_err(chip-&gt;dev, "Couldn't '%s' charging rc = %d\n", chip-&gt;charging_disabled ? "disable" : "enable", rc); &#125; else &#123; /* * Enable charging explictly, * because not sure the default behavior. */ rc = __smb358_charging_disable(chip, 0); if (rc) dev_err(chip-&gt;dev, "Couldn't enable charging\n"); &#125; /* * Workaround for recharge frequent issue: When battery is * greater than 4.2v, and charging is disabled, charger * stops switching. In such a case, system load is provided * by battery rather than input, even though input is still * there. Make reg09[0:3] to be a non-zero value which can * keep the switcher active */ rc = smb358_masked_write(chip, OTHER_CTRL_REG, CHG_LOW_BATT_THRESHOLD, SMB358_BATT_GOOD_THRE_2P5); if (rc) dev_err(chip-&gt;dev, "Couldn't write OTHER_CTRL_REG, rc = %d\n", rc); return rc;&#125;static enum power_supply_property smb358_battery_properties[] = &#123; POWER_SUPPLY_PROP_STATUS, POWER_SUPPLY_PROP_PRESENT, POWER_SUPPLY_PROP_CHARGING_ENABLED, POWER_SUPPLY_PROP_CHARGE_TYPE, POWER_SUPPLY_PROP_CAPACITY, POWER_SUPPLY_PROP_HEALTH, POWER_SUPPLY_PROP_TECHNOLOGY, POWER_SUPPLY_PROP_MODEL_NAME, POWER_SUPPLY_PROP_TEMP, POWER_SUPPLY_PROP_VOLTAGE_NOW,&#125;;static int smb358_get_prop_batt_status(struct smb358_charger *chip)&#123; int rc; u8 reg = 0; rc = smb358_read_reg(chip, STATUS_C_REG, &amp;reg); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't read STAT_C rc = %d\n", rc); return POWER_SUPPLY_STATUS_UNKNOWN; &#125; dev_dbg(chip-&gt;dev, "%s: STATUS_C_REG=%x\n", __func__, reg); if(reg == 0)&#123; chip-&gt;batt_full = false; return POWER_SUPPLY_STATUS_DISCHARGING; &#125;else if((reg &amp; STATUS_C_CHARGING_MASK) &amp;&amp; !(reg &amp; STATUS_C_CHG_ERR_STATUS_BIT))&#123; chip-&gt;batt_full = false; return POWER_SUPPLY_STATUS_CHARGING; &#125;else&#123; chip-&gt;batt_full = true; return POWER_SUPPLY_STATUS_FULL; &#125;&#125;static int smb358_get_prop_batt_present(struct smb358_charger *chip)&#123; return !chip-&gt;battery_missing;&#125;#define TEMP_ARR_SIZE 10static int smb358_get_prop_battery_voltage_now(struct smb358_charger *chip);static int smb358_battery_set_property(struct power_supply *psy, enum power_supply_property prop, const union power_supply_propval *val);static int smb358_get_prop_batt_capacity(struct smb358_charger *chip)&#123; union power_supply_propval ret = &#123;0, &#125;; int cur_v = 0,bat_voltage=0,ret_cap = 0; int cur_v_tmp = 0,p_ret_cap=0;#ifdef CONFIG_FOR_BROBDMOBI_R700 static int pre_cap = 0; static int cap_arr[TEMP_ARR_SIZE] = &#123;0&#125;; static int cnt = 0; int interval = 0, i = 0, sum = 0; int rc; u8 reg = 0;#if 0 if (chip-&gt;battery_missing) return 0;#endif cur_v_tmp = smb358_get_prop_battery_voltage_now(chip); cur_v = cur_v_tmp / 1000; cap_arr[cnt] = cur_v; cnt++; if (cnt != 0 &amp;&amp; (cnt % TEMP_ARR_SIZE) == 0) cnt = 0; for (; i &lt; TEMP_ARR_SIZE; i++) &#123; if (0 == cap_arr[i]) break; sum += cap_arr[i]; &#125; cur_v = sum / i; bat_voltage = batt_avg_adc(cur_v); //for (i = 0; i &lt; TEMP_ARR_SIZE; i++) // printk("the cap_v val is:%d\n", cap_arr[i]);#if 0 switch (cur_v) &#123; case 0 ... CAP_RAT10_VOL : ret_cap = 0; break; case CAP_RAT10_VOL + 1 ... CAP_RAT20_VOL : ret_cap = 10; break; case CAP_RAT20_VOL + 1 ... CAP_RAT30_VOL : ret_cap = 20; break; case CAP_RAT30_VOL + 1 ... CAP_RAT40_VOL : ret_cap = 30; break; case CAP_RAT40_VOL + 1 ... CAP_RAT50_VOL : ret_cap = 40; break; case CAP_RAT50_VOL + 1 ... CAP_RAT60_VOL : ret_cap = 50; break; case CAP_RAT60_VOL + 1 ... CAP_RAT70_VOL : ret_cap = 60; break; case CAP_RAT70_VOL + 1 ... CAP_RAT80_VOL : ret_cap = 70; break; case CAP_RAT80_VOL + 1 ... CAP_RAT90_VOL : ret_cap = 80; break; case CAP_RAT90_VOL + 1 ... CAP_RAT100_VOL : ret_cap = 90; break; case CAP_RAT100_VOL + 1 ... CAP_RATEND_VOL: ret_cap = 100; break; &#125;#endif rc = smb358_read_reg(chip, STATUS_C_REG, &amp;reg); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't read STAT_C rc = %d\n", rc); &#125; if ((reg &amp; STATUS_C_CHARGING_MASK) &amp;&amp; !(reg &amp; STATUS_C_CHG_ERR_STATUS_BIT))&#123; p_ret_cap = bat_get_chg_cap_percent(bat_voltage); ret_cap = batt_avg_percent(p_ret_cap); if(pre_cap &gt;= ret_cap &amp;&amp; pre_cap &lt; 100) ret_cap = pre_cap; // printk("batt_avg_percent = %d\n",ret_cap); &#125;else&#123; p_ret_cap = bat_get_dischg_cap_percent(bat_voltage); ret_cap = batt_avg_percent(p_ret_cap); if(ret_cap == 100) pre_cap = 100; if(pre_cap &lt;= ret_cap &amp;&amp; pre_cap &gt; 0) ret_cap = pre_cap; // printk("dis_batt_avg_percent = %d\n",ret_cap); if(ret_cap &lt; 2) kernel_power_off(); &#125; if (chip-&gt;batt_full)&#123; ret_cap = 100; // printk("chip-&gt;batt_full\n"); &#125;pre_cap &gt; ret_cap ? (interval = pre_cap - ret_cap) : (interval = ret_cap - pre_cap); if (pre_cap != ret_cap &amp;&amp; interval &lt;= 10) &#123; // if the interval is more than 10, ignor it. ret.intval = ret_cap; smb358_battery_set_property(&amp;chip-&gt;batt_psy, POWER_SUPPLY_PROP_CAPACITY, &amp;ret); &#125; pre_cap = ret_cap; return ret_cap;#else if (chip-&gt;fake_battery_soc &gt;= 0) return chip-&gt;fake_battery_soc; if (chip-&gt;bms_psy) &#123; chip-&gt;bms_psy-&gt;get_property(chip-&gt;bms_psy, POWER_SUPPLY_PROP_CAPACITY, &amp;ret); return ret.intval; &#125; dev_dbg(chip-&gt;dev, "Couldn't get bms_psy, return default capacity\n"); return SMB358_DEFAULT_BATT_CAPACITY;#endif&#125;static int smb358_get_prop_charge_type(struct smb358_charger *chip)&#123; int rc; u8 reg = 0; rc = smb358_read_reg(chip, STATUS_C_REG, &amp;reg); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't read STAT_C rc = %d\n", rc); return POWER_SUPPLY_CHARGE_TYPE_UNKNOWN; &#125; dev_dbg(chip-&gt;dev, "%s: STATUS_C_REG=%x\n", __func__, reg); reg &amp;= STATUS_C_CHARGING_MASK; if (reg == STATUS_C_FAST_CHARGING) return POWER_SUPPLY_CHARGE_TYPE_FAST; else if (reg == STATUS_C_TAPER_CHARGING) return POWER_SUPPLY_CHARGE_TYPE_TAPER; else if (reg == STATUS_C_PRE_CHARGING) return POWER_SUPPLY_CHARGE_TYPE_TRICKLE; else return POWER_SUPPLY_CHARGE_TYPE_NONE;&#125;static int smb358_get_prop_batt_temp(struct smb358_charger *chip);static int smb358_get_prop_batt_health(struct smb358_charger *chip)&#123; union power_supply_propval ret = &#123;0, &#125;;#ifdef CONFIG_FOR_BROBDMOBI_R700 int temp_adc = 0, rc; temp_adc = smb358_get_prop_batt_temp(chip); switch (temp_adc) &#123; case 0 ... TEMP_HOT_VOLTAGE: ret.intval = POWER_SUPPLY_HEALTH_OVERHEAT; rc = smb358_charging_disable(chip, SOC, true); if (rc &lt; 0) &#123; dev_err(chip-&gt;dev, "Couldn't set charging disable rc = %d\n", rc); &#125; if (chip-&gt;battery_missing) chip-&gt;battery_missing = false; //kernel_power_off(); break; case TEMP_HOT_VOLTAGE + 1 ... TEMP_COLD_VOLTAGE: ret.intval = POWER_SUPPLY_HEALTH_GOOD; if (chip-&gt;battery_missing) chip-&gt;battery_missing = false; //temperature is ok,go to charging state rc = smb358_charging_disable(chip, SOC, false); if (rc &lt; 0) &#123; dev_err(chip-&gt;dev, "Couldn't set charging disable rc = %d\n", rc); &#125; if (chip-&gt;battery_missing) chip-&gt;battery_missing = false; break; case TEMP_COLD_VOLTAGE + 1 ... TEMP_OVER_COLD_VOLTAGE: ret.intval = POWER_SUPPLY_HEALTH_COLD; rc = smb358_charging_disable(chip, SOC, true); if (rc &lt; 0) &#123; dev_err(chip-&gt;dev, "Couldn't set charging disable rc = %d\n", rc); &#125; //kernel_power_off(); break; default: ret.intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE; //dev_err(chip-&gt;dev, "it is unknow temp, disable the charging = %d\n", temp_adc); dev_err(chip-&gt;dev, "it is unknow temp %d\n", temp_adc); //rc = smb358_charging_disable(chip, SOC, true); //if (rc &lt; 0) &#123; // dev_err(chip-&gt;dev, "Couldn't set charging disable rc = %d\n", rc); //&#125; if (!chip-&gt;battery_missing) chip-&gt;battery_missing = true; break; &#125;#else if (chip-&gt;batt_hot) ret.intval = POWER_SUPPLY_HEALTH_OVERHEAT; else if (chip-&gt;batt_cold) ret.intval = POWER_SUPPLY_HEALTH_COLD; else if (chip-&gt;batt_warm) ret.intval = POWER_SUPPLY_HEALTH_WARM; else if (chip-&gt;batt_cool) ret.intval = POWER_SUPPLY_HEALTH_COOL; else ret.intval = POWER_SUPPLY_HEALTH_GOOD;#endif return ret.intval;&#125;#define DEFAULT_TEMP 250static int smb358_get_prop_batt_temp(struct smb358_charger *chip)&#123; int rc = 0; struct qpnp_vadc_result results;#ifdef CONFIG_FOR_BROBDMOBI_R700 rc = qpnp_vadc_read(chip-&gt;vadc_dev, P_MUX6_1_1, &amp;results);#else if (!smb358_get_prop_batt_present(chip) || !chip-&gt;vadc_dev || !chip-&gt;using_pmic_therm) return DEFAULT_TEMP; rc = qpnp_vadc_read(chip-&gt;vadc_dev, LR_MUX1_BATT_THERM, &amp;results);#endif if (rc) &#123; pr_debug("Unable to read batt temperature rc=%d\n", rc); return DEFAULT_TEMP; &#125; pr_debug("get_bat_temp %d, %lld\n", results.adc_code, results.physical); return (int)results.physical;&#125;static intsmb358_get_prop_battery_voltage_now(struct smb358_charger *chip)&#123; int rc = 0; struct qpnp_vadc_result results; if (!chip-&gt;vadc_dev || !chip-&gt;pmic_vbat_sns) return 0; rc = qpnp_vadc_read(chip-&gt;vadc_dev, VBAT_SNS, &amp;results); if (rc) &#123; pr_err("Unable to read vbat rc=%d\n", rc); return 0; &#125; return results.physical;&#125;static int smb358_set_usb_chg_current(struct smb358_charger *chip, int current_ma)&#123; int i, rc = 0; u8 reg1 = 0, reg2 = 0, mask = 0; dev_dbg(chip-&gt;dev, "%s: USB current_ma = %d\n", __func__, current_ma); if (chip-&gt;chg_autonomous_mode) &#123; dev_dbg(chip-&gt;dev, "%s: Charger in autonmous mode\n", __func__); return 0; &#125; if (current_ma &lt; USB3_MIN_CURRENT_MA &amp;&amp; current_ma != 2) current_ma = USB2_MIN_CURRENT_MA; if (current_ma == USB2_MIN_CURRENT_MA) &#123; /* USB 2.0 - 100mA */ reg1 &amp;= ~USB3_ENABLE_BIT; reg2 &amp;= ~CMD_B_CHG_USB_500_900_ENABLE_BIT; &#125; else if (current_ma == USB2_MAX_CURRENT_MA) &#123; /* USB 2.0 - 500mA */ reg1 &amp;= ~USB3_ENABLE_BIT; reg2 |= CMD_B_CHG_USB_500_900_ENABLE_BIT; &#125; else if (current_ma == USB3_MAX_CURRENT_MA) &#123; /* USB 3.0 - 900mA */ reg1 |= USB3_ENABLE_BIT; reg2 |= CMD_B_CHG_USB_500_900_ENABLE_BIT; &#125; else if (current_ma &gt; USB2_MAX_CURRENT_MA) &#123; /* HC mode - if none of the above */ reg2 |= CMD_B_CHG_HC_ENABLE_BIT; for (i = ARRAY_SIZE(chg_current) - 1; i &gt;= 0; i--) &#123; if (chg_current[i] &lt;= current_ma) break; &#125; if (i &lt; 0) &#123; dev_err(chip-&gt;dev, "Cannot find %dmA\n", current_ma); i = 0; &#125; i = i &lt;&lt; AC_CHG_CURRENT_SHIFT; rc = smb358_masked_write(chip, CHG_OTH_CURRENT_CTRL_REG, AC_CHG_CURRENT_MASK, i); if (rc) dev_err(chip-&gt;dev, "Couldn't set input mA rc=%d\n", rc); &#125; mask = CMD_B_CHG_HC_ENABLE_BIT | CMD_B_CHG_USB_500_900_ENABLE_BIT; rc = smb358_masked_write(chip, CMD_B_REG, mask, reg2); if (rc &lt; 0) dev_err(chip-&gt;dev, "Couldn't set charging mode rc = %d\n", rc); mask = USB3_ENABLE_MASK; rc = smb358_masked_write(chip, SYSOK_AND_USB3_REG, mask, reg1); if (rc &lt; 0) dev_err(chip-&gt;dev, "Couldn't set USB3 mode rc = %d\n", rc); /* Only set suspend bit when chg present and current_ma = 2 */ //if (current_ma == 2 &amp;&amp; chip-&gt;chg_present) &#123; if (current_ma == 2 &amp;&amp; chip-&gt;chg_present &amp;&amp; !chip-&gt;battery_missing) &#123; rc = smb358_path_suspend(chip, CURRENT, true); if (rc &lt; 0) dev_err(chip-&gt;dev, "Couldn't suspend rc = %d\n", rc); &#125; else &#123; rc = smb358_path_suspend(chip, CURRENT, false); if (rc &lt; 0) dev_err(chip-&gt;dev, "Couldn't set susp rc = %d\n", rc); &#125; return rc;&#125;static intsmb358_batt_property_is_writeable(struct power_supply *psy, enum power_supply_property psp)&#123; switch (psp) &#123; case POWER_SUPPLY_PROP_CHARGING_ENABLED: case POWER_SUPPLY_PROP_CAPACITY: return 1; default: break; &#125; return 0;&#125;static int bound_soc(int soc)&#123; soc = max(0, soc); soc = min(soc, 100); return soc;&#125;static int smb358_battery_set_property(struct power_supply *psy, enum power_supply_property prop, const union power_supply_propval *val)&#123; int rc; struct smb358_charger *chip = container_of(psy, struct smb358_charger, batt_psy); switch (prop) &#123; case POWER_SUPPLY_PROP_STATUS: if (!chip-&gt;bms_controlled_charging) return -EINVAL; switch (val-&gt;intval) &#123; case POWER_SUPPLY_STATUS_FULL: rc = smb358_charging_disable(chip, SOC, true); if (rc &lt; 0) &#123; dev_err(chip-&gt;dev, "Couldn't set charging disable rc = %d\n", rc); &#125; else &#123; chip-&gt;batt_full = true; dev_dbg(chip-&gt;dev, "status = FULL, batt_full = %d\n", chip-&gt;batt_full); &#125; break; case POWER_SUPPLY_STATUS_DISCHARGING: chip-&gt;batt_full = false; power_supply_changed(&amp;chip-&gt;batt_psy); dev_dbg(chip-&gt;dev, "status = DISCHARGING, batt_full = %d\n", chip-&gt;batt_full); break; case POWER_SUPPLY_STATUS_CHARGING: rc = smb358_charging_disable(chip, SOC, false); if (rc &lt; 0) &#123; dev_err(chip-&gt;dev, "Couldn't set charging disable rc = %d\n", rc); &#125; else &#123; chip-&gt;batt_full = false; dev_dbg(chip-&gt;dev, "status = CHARGING, batt_full = %d\n", chip-&gt;batt_full); &#125; break; default: return -EINVAL; &#125; break; case POWER_SUPPLY_PROP_CHARGING_ENABLED: smb358_charging_disable(chip, USER, !val-&gt;intval); smb358_path_suspend(chip, USER, !val-&gt;intval); break; case POWER_SUPPLY_PROP_CAPACITY: chip-&gt;fake_battery_soc = bound_soc(val-&gt;intval); power_supply_changed(&amp;chip-&gt;batt_psy); break; default: return -EINVAL; &#125; return 0;&#125;static int smb358_battery_get_property(struct power_supply *psy, enum power_supply_property prop, union power_supply_propval *val)&#123; struct smb358_charger *chip = container_of(psy, struct smb358_charger, batt_psy); switch (prop) &#123; case POWER_SUPPLY_PROP_STATUS: val-&gt;intval = smb358_get_prop_batt_status(chip); break; case POWER_SUPPLY_PROP_PRESENT: val-&gt;intval = smb358_get_prop_batt_present(chip); break; case POWER_SUPPLY_PROP_CAPACITY: val-&gt;intval = smb358_get_prop_batt_capacity(chip); break; case POWER_SUPPLY_PROP_CHARGING_ENABLED: val-&gt;intval = !(chip-&gt;charging_disabled_status &amp; USER); break; case POWER_SUPPLY_PROP_CHARGE_TYPE: val-&gt;intval = smb358_get_prop_charge_type(chip); break; case POWER_SUPPLY_PROP_HEALTH: val-&gt;intval = smb358_get_prop_batt_health(chip); break; case POWER_SUPPLY_PROP_TECHNOLOGY: val-&gt;intval = POWER_SUPPLY_TECHNOLOGY_LION; break; case POWER_SUPPLY_PROP_MODEL_NAME: val-&gt;strval = "SMB358"; break; case POWER_SUPPLY_PROP_TEMP: val-&gt;intval = smb358_get_prop_batt_temp(chip); break; case POWER_SUPPLY_PROP_VOLTAGE_NOW: val-&gt;intval = smb358_get_prop_battery_voltage_now(chip); break; default: return -EINVAL; &#125; return 0;&#125;static int apsd_complete(struct smb358_charger *chip, u8 status)&#123; int rc; u8 reg = 0; enum power_supply_type type = POWER_SUPPLY_TYPE_UNKNOWN; /* * If apsd is disabled, charger detection is done by * DCIN UV irq. * status = ZERO - indicates charger removed, handled * by DCIN UV irq */ if (chip-&gt;disable_apsd || status == 0) &#123; dev_dbg(chip-&gt;dev, "APSD %s, status = %d\n", chip-&gt;disable_apsd ? "disabled" : "enabled", !!status); return 0; &#125; rc = smb358_read_reg(chip, STATUS_D_REG, &amp;reg); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't read STATUS D rc = %d\n", rc); return rc; &#125; dev_dbg(chip-&gt;dev, "%s: STATUS_D_REG=%x\n", __func__, reg); switch (reg &amp; STATUS_D_CHARGING_PORT_MASK) &#123; case STATUS_D_PORT_ACA_DOCK: case STATUS_D_PORT_ACA_C: case STATUS_D_PORT_ACA_B: case STATUS_D_PORT_ACA_A: type = POWER_SUPPLY_TYPE_USB_ACA; break; case STATUS_D_PORT_CDP: type = POWER_SUPPLY_TYPE_USB_CDP; break; case STATUS_D_PORT_DCP: type = POWER_SUPPLY_TYPE_USB_DCP; break; case STATUS_D_PORT_SDP: type = POWER_SUPPLY_TYPE_USB; break; case STATUS_D_PORT_OTHER: type = POWER_SUPPLY_TYPE_USB_DCP; break; default: type = POWER_SUPPLY_TYPE_USB; break; &#125; chip-&gt;chg_present = !!status; dev_dbg(chip-&gt;dev, "APSD complete. USB type detected=%d chg_present=%d", type, chip-&gt;chg_present); power_supply_set_supply_type(chip-&gt;usb_psy, type); /* SMB is now done sampling the D+/D- lines, indicate USB driver */ dev_dbg(chip-&gt;dev, "%s updating usb_psy present=%d", __func__, chip-&gt;chg_present); power_supply_set_present(chip-&gt;usb_psy, chip-&gt;chg_present); return 0;&#125;static int check_tmep(struct smb358_charger *chip, u8 status)&#123; int temp_vol = 0; if (!chip-&gt;battery_missing) &#123; pr_err("the status is:%#x\n", status); temp_vol = smb358_get_prop_batt_temp(chip); if (temp_vol &gt; TEMP_OVER_COLD_VOLTAGE) chip-&gt;battery_missing = true; &#125; return 0;&#125;static int chg_uv(struct smb358_charger *chip, u8 status)&#123; int rc; /* use this to detect USB insertion only if !apsd */ if (chip-&gt;disable_apsd &amp;&amp; status == 0) &#123; chip-&gt;chg_present = true; dev_dbg(chip-&gt;dev, "%s updating usb_psy present=%d", __func__, chip-&gt;chg_present); power_supply_set_supply_type(chip-&gt;usb_psy, POWER_SUPPLY_TYPE_USB); power_supply_set_present(chip-&gt;usb_psy, chip-&gt;chg_present); if (chip-&gt;bms_controlled_charging) &#123; /* * Disable SOC based USB suspend to enable charging on * USB insertion. */ rc = smb358_charging_disable(chip, SOC, false); if (rc &lt; 0) dev_err(chip-&gt;dev, "Couldn't disable usb suspend rc = %d\n", rc); &#125; &#125; if (status != 0) &#123; chip-&gt;chg_present = false; dev_dbg(chip-&gt;dev, "%s updating usb_psy present=%d", __func__, chip-&gt;chg_present); /* we can't set usb_psy as UNKNOWN here, will lead USERSPACE issue */ power_supply_set_present(chip-&gt;usb_psy, chip-&gt;chg_present); &#125; power_supply_changed(chip-&gt;usb_psy); dev_dbg(chip-&gt;dev, "chip-&gt;chg_present = %d\n", chip-&gt;chg_present); return 0;&#125;static int chg_ov(struct smb358_charger *chip, u8 status)&#123; u8 psy_health_sts; if (status) psy_health_sts = POWER_SUPPLY_HEALTH_OVERVOLTAGE; else psy_health_sts = POWER_SUPPLY_HEALTH_GOOD; power_supply_set_health_state( chip-&gt;usb_psy, psy_health_sts); power_supply_changed(chip-&gt;usb_psy); return 0;&#125;#define STATUS_FAST_CHARGING BIT(6)static int fast_chg(struct smb358_charger *chip, u8 status)&#123; dev_dbg(chip-&gt;dev, "%s\n", __func__); if (status &amp; STATUS_FAST_CHARGING) chip-&gt;batt_full = false; return 0;&#125;static int chg_term(struct smb358_charger *chip, u8 status)&#123; dev_dbg(chip-&gt;dev, "%s\n", __func__); if (!chip-&gt;iterm_disabled) chip-&gt;batt_full = !!status; return 0;&#125;static int taper_chg(struct smb358_charger *chip, u8 status)&#123; dev_dbg(chip-&gt;dev, "%s\n", __func__); return 0;&#125;static int chg_recharge(struct smb358_charger *chip, u8 status)&#123; dev_dbg(chip-&gt;dev, "%s, status = %d\n", __func__, !!status); /* to check the status mean */ chip-&gt;batt_full = !status; return 0;&#125;static void smb358_chg_set_appropriate_battery_current( struct smb358_charger *chip)&#123; int rc; unsigned int current_max = chip-&gt;fastchg_current_max_ma; if (chip-&gt;batt_cool) current_max = min(current_max, chip-&gt;cool_bat_ma); if (chip-&gt;batt_warm) current_max = min(current_max, chip-&gt;warm_bat_ma); dev_dbg(chip-&gt;dev, "setting %dmA", current_max); rc = smb358_fastchg_current_set(chip, current_max); if (rc) dev_err(chip-&gt;dev, "Couldn't set charging current rc = %d\n", rc);&#125;static void smb358_chg_set_appropriate_vddmax( struct smb358_charger *chip)&#123; int rc; unsigned int vddmax = chip-&gt;vfloat_mv; if (chip-&gt;batt_cool) vddmax = min(vddmax, chip-&gt;cool_bat_mv); if (chip-&gt;batt_warm) vddmax = min(vddmax, chip-&gt;warm_bat_mv); dev_dbg(chip-&gt;dev, "setting %dmV\n", vddmax); rc = smb358_float_voltage_set(chip, vddmax); if (rc) dev_err(chip-&gt;dev, "Couldn't set float voltage rc = %d\n", rc);&#125;#define HYSTERESIS_DECIDEGC 20static void smb_chg_adc_notification(enum qpnp_tm_state state, void *ctx)&#123; struct smb358_charger *chip = ctx; bool bat_hot = 0, bat_cold = 0, bat_present = 0, bat_warm = 0, bat_cool = 0; int temp; if (state &gt;= ADC_TM_STATE_NUM) &#123; pr_err("invallid state parameter %d\n", state); return; &#125; temp = smb358_get_prop_batt_temp(chip); pr_debug("temp = %d state = %s\n", temp, state == ADC_TM_WARM_STATE ? "hot" : "cold"); if (state == ADC_TM_WARM_STATE) &#123; if (temp &gt;= chip-&gt;hot_bat_decidegc) &#123; bat_hot = true; bat_warm = false; bat_cold = false; bat_cool = false; bat_present = true; chip-&gt;adc_param.low_temp = chip-&gt;hot_bat_decidegc - HYSTERESIS_DECIDEGC; chip-&gt;adc_param.state_request = ADC_TM_COOL_THR_ENABLE; &#125; else if (temp &gt;= chip-&gt;warm_bat_decidegc &amp;&amp; chip-&gt;jeita_supported) &#123; bat_hot = false; bat_warm = true; bat_cold = false; bat_cool = false; bat_present = true; chip-&gt;adc_param.low_temp = chip-&gt;warm_bat_decidegc - HYSTERESIS_DECIDEGC; chip-&gt;adc_param.high_temp = chip-&gt;hot_bat_decidegc; &#125; else if (temp &gt;= chip-&gt;cool_bat_decidegc &amp;&amp; chip-&gt;jeita_supported) &#123; bat_hot = false; bat_warm = false; bat_cold = false; bat_cool = false; bat_present = true; chip-&gt;adc_param.low_temp = chip-&gt;cool_bat_decidegc - HYSTERESIS_DECIDEGC; chip-&gt;adc_param.high_temp = chip-&gt;warm_bat_decidegc; &#125; else if (temp &gt;= chip-&gt;cold_bat_decidegc) &#123; bat_hot = false; bat_warm = false; bat_cold = false; bat_cool = true; bat_present = true; chip-&gt;adc_param.low_temp = chip-&gt;cold_bat_decidegc - HYSTERESIS_DECIDEGC; if (chip-&gt;jeita_supported) chip-&gt;adc_param.high_temp = chip-&gt;cool_bat_decidegc; else chip-&gt;adc_param.high_temp = chip-&gt;hot_bat_decidegc; chip-&gt;adc_param.state_request = ADC_TM_HIGH_LOW_THR_ENABLE; &#125; else if (temp &gt;= chip-&gt;bat_present_decidegc) &#123; bat_hot = false; bat_warm = false; bat_cold = true; bat_cool = false; bat_present = true; chip-&gt;adc_param.high_temp = chip-&gt;cold_bat_decidegc; chip-&gt;adc_param.low_temp = chip-&gt;bat_present_decidegc - HYSTERESIS_DECIDEGC; chip-&gt;adc_param.state_request = ADC_TM_HIGH_LOW_THR_ENABLE; &#125; &#125; else &#123; if (temp &lt;= chip-&gt;bat_present_decidegc) &#123; bat_cold = true; bat_cool = false; bat_hot = false; bat_warm = false; bat_present = false; chip-&gt;adc_param.high_temp = chip-&gt;bat_present_decidegc + HYSTERESIS_DECIDEGC; chip-&gt;adc_param.state_request = ADC_TM_WARM_THR_ENABLE; &#125; else if (temp &lt;= chip-&gt;cold_bat_decidegc) &#123; bat_hot = false; bat_warm = false; bat_cold = true; bat_cool = false; bat_present = true; chip-&gt;adc_param.high_temp = chip-&gt;cold_bat_decidegc + HYSTERESIS_DECIDEGC; /* add low_temp to enable batt present check */ chip-&gt;adc_param.low_temp = chip-&gt;bat_present_decidegc; chip-&gt;adc_param.state_request = ADC_TM_HIGH_LOW_THR_ENABLE; &#125; else if (temp &lt;= chip-&gt;cool_bat_decidegc &amp;&amp; chip-&gt;jeita_supported) &#123; bat_hot = false; bat_warm = false; bat_cold = false; bat_cool = true; bat_present = true; chip-&gt;adc_param.high_temp = chip-&gt;cool_bat_decidegc + HYSTERESIS_DECIDEGC; chip-&gt;adc_param.low_temp = chip-&gt;cold_bat_decidegc; chip-&gt;adc_param.state_request = ADC_TM_HIGH_LOW_THR_ENABLE; &#125; else if (temp &lt;= chip-&gt;warm_bat_decidegc &amp;&amp; chip-&gt;jeita_supported) &#123; bat_hot = false; bat_warm = false; bat_cold = false; bat_cool = false; bat_present = true; chip-&gt;adc_param.high_temp = chip-&gt;warm_bat_decidegc + HYSTERESIS_DECIDEGC; chip-&gt;adc_param.low_temp = chip-&gt;cool_bat_decidegc; chip-&gt;adc_param.state_request = ADC_TM_HIGH_LOW_THR_ENABLE; &#125; else if (temp &lt;= chip-&gt;hot_bat_decidegc) &#123; bat_hot = false; bat_warm = true; bat_cold = false; bat_cool = false; bat_present = true; if (chip-&gt;jeita_supported) chip-&gt;adc_param.low_temp = chip-&gt;warm_bat_decidegc; else chip-&gt;adc_param.low_temp = chip-&gt;cold_bat_decidegc; chip-&gt;adc_param.high_temp = chip-&gt;hot_bat_decidegc + HYSTERESIS_DECIDEGC; chip-&gt;adc_param.state_request = ADC_TM_HIGH_LOW_THR_ENABLE; &#125; &#125; if (bat_present) chip-&gt;battery_missing = false; else chip-&gt;battery_missing = true; if (bat_hot ^ chip-&gt;batt_hot || bat_cold ^ chip-&gt;batt_cold) &#123; chip-&gt;batt_hot = bat_hot; chip-&gt;batt_cold = bat_cold; /* stop charging explicitly since we use PMIC thermal pin*/ if (bat_hot || bat_cold || chip-&gt;battery_missing) smb358_charging_disable(chip, THERMAL, 1); else smb358_charging_disable(chip, THERMAL, 0); &#125; if ((chip-&gt;batt_warm ^ bat_warm || chip-&gt;batt_cool ^ bat_cool) &amp;&amp; chip-&gt;jeita_supported) &#123; chip-&gt;batt_warm = bat_warm; chip-&gt;batt_cool = bat_cool; smb358_chg_set_appropriate_battery_current(chip); smb358_chg_set_appropriate_vddmax(chip); &#125; pr_debug("hot %d, cold %d, warm %d, cool %d, jeita supported %d, missing %d, low = %d deciDegC, high = %d deciDegC\n", chip-&gt;batt_hot, chip-&gt;batt_cold, chip-&gt;batt_warm, chip-&gt;batt_cool, chip-&gt;jeita_supported, chip-&gt;battery_missing, chip-&gt;adc_param.low_temp, chip-&gt;adc_param.high_temp); if (qpnp_adc_tm_channel_measure(chip-&gt;adc_tm_dev, &amp;chip-&gt;adc_param)) pr_err("request ADC error\n");&#125;/* only for SMB thermal */static int hot_hard_handler(struct smb358_charger *chip, u8 status)&#123; pr_debug("status = 0x%02x\n", status); chip-&gt;batt_hot = !!status; return 0;&#125;static int cold_hard_handler(struct smb358_charger *chip, u8 status)&#123; pr_debug("status = 0x%02x\n", status); chip-&gt;batt_cold = !!status; return 0;&#125;static int hot_soft_handler(struct smb358_charger *chip, u8 status)&#123; pr_debug("status = 0x%02x\n", status); chip-&gt;batt_warm = !!status; return 0;&#125;static int cold_soft_handler(struct smb358_charger *chip, u8 status)&#123; pr_debug("status = 0x%02x\n", status); chip-&gt;batt_cool = !!status; return 0;&#125;static int battery_missing(struct smb358_charger *chip, u8 status)&#123; int temp_vol = 0; pr_err("=========the status is:%#x\n", status); if (status) &#123; temp_vol = smb358_get_prop_batt_temp(chip); if (temp_vol &gt; TEMP_OVER_COLD_VOLTAGE) chip-&gt;battery_missing = true; &#125; else chip-&gt;battery_missing = !!status; return 0;&#125;static struct irq_handler_info handlers[] = &#123; [0] = &#123; .stat_reg = IRQ_A_REG, .val = 0, .prev_val = 0, .irq_info = &#123; &#123; .name = "cold_soft", .smb_irq = cold_soft_handler, &#125;, &#123; .name = "hot_soft", .smb_irq = hot_soft_handler, &#125;, &#123; .name = "cold_hard", .smb_irq = cold_hard_handler, &#125;, &#123; .name = "hot_hard", .smb_irq = hot_hard_handler, &#125;, &#125;, &#125;, [1] = &#123; .stat_reg = IRQ_B_REG, .val = 0, .prev_val = 0, .irq_info = &#123; &#123; .name = "chg_hot", &#125;, &#123; .name = "vbat_low", &#125;, &#123; .name = "battery_missing", .smb_irq = battery_missing &#125;, &#123; .name = "battery_ov", &#125;, &#125;, &#125;, [2] = &#123; .stat_reg = IRQ_C_REG, .val = 0, .prev_val = 0, .irq_info = &#123; &#123; .name = "chg_term", .smb_irq = chg_term, &#125;, &#123; .name = "taper", .smb_irq = taper_chg, &#125;, &#123; .name = "recharge", .smb_irq = chg_recharge, &#125;, &#123; .name = "fast_chg", .smb_irq = fast_chg, &#125;, &#125;, &#125;, [3] = &#123; .stat_reg = IRQ_D_REG, .val = 0, .prev_val = 0, .irq_info = &#123; &#123; .name = "prechg_timeout", &#125;, &#123; .name = "safety_timeout", &#125;, &#123; .name = "aicl_complete", &#125;, &#123; .name = "src_detect", .smb_irq = apsd_complete, &#125;, &#125;, &#125;, [4] = &#123; .stat_reg = IRQ_E_REG, .val = 0, .prev_val = 0, .irq_info = &#123; &#123; .name = "usbin_uv", .smb_irq = chg_uv, &#125;, &#123; .name = "usbin_ov", .smb_irq = chg_ov, &#125;, &#123; .name = "unknown", &#125;, &#123; .name = "unknown", //.name = "check_tmep", //.smb_irq = check_tmep, &#125;, &#125;, &#125;, [5] = &#123; .stat_reg = IRQ_F_REG, .val = 0, .prev_val = 0, .irq_info = &#123; &#123; .name = "power_ok", &#125;, &#123; .name = "otg_det", &#125;, &#123; .name = "otg_batt_uv", &#125;, &#123; .name = "otg_oc", &#125;, &#125;, &#125;,&#125;;#define IRQ_LATCHED_MASK 0x02#define IRQ_STATUS_MASK 0x01#define BITS_PER_IRQ 2static irqreturn_t smb358_chg_stat_handler(int irq, void *dev_id)&#123; struct smb358_charger *chip = dev_id; int i, j; u8 triggered; u8 changed; u8 rt_stat, prev_rt_stat; int rc; int handler_count = 0; mutex_lock(&amp;chip-&gt;irq_complete); chip-&gt;irq_waiting = true; if (!chip-&gt;resume_completed) &#123; dev_dbg(chip-&gt;dev, "IRQ triggered before device-resume\n"); disable_irq_nosync(irq); mutex_unlock(&amp;chip-&gt;irq_complete); return IRQ_HANDLED; &#125; chip-&gt;irq_waiting = false; for (i = 0; i &lt; ARRAY_SIZE(handlers); i++) &#123; rc = smb358_read_reg(chip, handlers[i].stat_reg, &amp;handlers[i].val); if (rc &lt; 0) &#123; dev_err(chip-&gt;dev, "Couldn't read %d rc = %d\n", handlers[i].stat_reg, rc); continue; &#125; for (j = 0; j &lt; ARRAY_SIZE(handlers[i].irq_info); j++) &#123; triggered = handlers[i].val &amp; (IRQ_LATCHED_MASK &lt;&lt; (j * BITS_PER_IRQ)); rt_stat = handlers[i].val &amp; (IRQ_STATUS_MASK &lt;&lt; (j * BITS_PER_IRQ)); prev_rt_stat = handlers[i].prev_val &amp; (IRQ_STATUS_MASK &lt;&lt; (j * BITS_PER_IRQ)); changed = prev_rt_stat ^ rt_stat; if (triggered || changed) rt_stat ? handlers[i].irq_info[j].high++ : handlers[i].irq_info[j].low++; if ((triggered || changed) &amp;&amp; handlers[i].irq_info[j].smb_irq != NULL) &#123; handler_count++; rc = handlers[i].irq_info[j].smb_irq(chip, rt_stat); if (rc &lt; 0) dev_err(chip-&gt;dev, "Couldn't handle %d irq for reg 0x%02x rc = %d\n", j, handlers[i].stat_reg, rc); &#125; &#125; handlers[i].prev_val = handlers[i].val; &#125; pr_debug("handler count = %d\n", handler_count); if (handler_count) &#123; pr_debug("batt psy changed\n"); power_supply_changed(&amp;chip-&gt;batt_psy); &#125; mutex_unlock(&amp;chip-&gt;irq_complete); return IRQ_HANDLED;&#125;static irqreturn_t smb358_chg_valid_handler(int irq, void *dev_id)&#123; struct smb358_charger *chip = dev_id; int present; present = gpio_get_value_cansleep(chip-&gt;chg_valid_gpio); if (present &lt; 0) &#123; dev_err(chip-&gt;dev, "Couldn't read chg_valid gpio=%d\n", chip-&gt;chg_valid_gpio); return IRQ_HANDLED; &#125; present ^= chip-&gt;chg_valid_act_low; dev_dbg(chip-&gt;dev, "%s: chg_present = %d\n", __func__, present); if (present != chip-&gt;chg_present) &#123; chip-&gt;chg_present = present; dev_dbg(chip-&gt;dev, "%s updating usb_psy present=%d", __func__, chip-&gt;chg_present); power_supply_set_present(chip-&gt;usb_psy, chip-&gt;chg_present); &#125; return IRQ_HANDLED;&#125;static void smb358_external_power_changed(struct power_supply *psy)&#123; struct smb358_charger *chip = container_of(psy, struct smb358_charger, batt_psy); union power_supply_propval prop = &#123;0,&#125;; int rc, current_limit = 0; if (chip-&gt;bms_psy_name) chip-&gt;bms_psy = power_supply_get_by_name((char *)chip-&gt;bms_psy_name); rc = chip-&gt;usb_psy-&gt;get_property(chip-&gt;usb_psy, POWER_SUPPLY_PROP_CURRENT_MAX, &amp;prop); if (rc) dev_err(chip-&gt;dev, "Couldn't read USB current_max property, rc=%d\n", rc); else current_limit = prop.intval / 1000; smb358_enable_volatile_writes(chip); smb358_set_usb_chg_current(chip, current_limit); dev_dbg(chip-&gt;dev, "current_limit = %d\n", current_limit);&#125;#if defined(CONFIG_DEBUG_FS)#define LAST_CNFG_REG 0x13static int show_cnfg_regs(struct seq_file *m, void *data)&#123; struct smb358_charger *chip = m-&gt;private; int rc; u8 reg; u8 addr; for (addr = 0; addr &lt;= LAST_CNFG_REG; addr++) &#123; rc = smb358_read_reg(chip, addr, &amp;reg); if (!rc) seq_printf(m, "0x%02x = 0x%02x\n", addr, reg); &#125; return 0;&#125;static int cnfg_debugfs_open(struct inode *inode, struct file *file)&#123; struct smb358_charger *chip = inode-&gt;i_private; return single_open(file, show_cnfg_regs, chip);&#125;static const struct file_operations cnfg_debugfs_ops = &#123; .owner = THIS_MODULE, .open = cnfg_debugfs_open, .read = seq_read, .llseek = seq_lseek, .release = single_release,&#125;;#define FIRST_CMD_REG 0x30#define LAST_CMD_REG 0x33static int show_cmd_regs(struct seq_file *m, void *data)&#123; struct smb358_charger *chip = m-&gt;private; int rc; u8 reg; u8 addr; for (addr = FIRST_CMD_REG; addr &lt;= LAST_CMD_REG; addr++) &#123; rc = smb358_read_reg(chip, addr, &amp;reg); if (!rc) seq_printf(m, "0x%02x = 0x%02x\n", addr, reg); &#125; return 0;&#125;static int cmd_debugfs_open(struct inode *inode, struct file *file)&#123; struct smb358_charger *chip = inode-&gt;i_private; return single_open(file, show_cmd_regs, chip);&#125;static const struct file_operations cmd_debugfs_ops = &#123; .owner = THIS_MODULE, .open = cmd_debugfs_open, .read = seq_read, .llseek = seq_lseek, .release = single_release,&#125;;#define FIRST_STATUS_REG 0x35#define LAST_STATUS_REG 0x3Fstatic int show_status_regs(struct seq_file *m, void *data)&#123; struct smb358_charger *chip = m-&gt;private; int rc; u8 reg; u8 addr; for (addr = FIRST_STATUS_REG; addr &lt;= LAST_STATUS_REG; addr++) &#123; rc = smb358_read_reg(chip, addr, &amp;reg); if (!rc) seq_printf(m, "0x%02x = 0x%02x\n", addr, reg); &#125; return 0;&#125;static int status_debugfs_open(struct inode *inode, struct file *file)&#123; struct smb358_charger *chip = inode-&gt;i_private; return single_open(file, show_status_regs, chip);&#125;static const struct file_operations status_debugfs_ops = &#123; .owner = THIS_MODULE, .open = status_debugfs_open, .read = seq_read, .llseek = seq_lseek, .release = single_release,&#125;;static int show_irq_count(struct seq_file *m, void *data)&#123; int i, j, total = 0; for (i = 0; i &lt; ARRAY_SIZE(handlers); i++) for (j = 0; j &lt; 4; j++) &#123; seq_printf(m, "%s=%d\t(high=%d low=%d)\n", handlers[i].irq_info[j].name, handlers[i].irq_info[j].high + handlers[i].irq_info[j].low, handlers[i].irq_info[j].high, handlers[i].irq_info[j].low); total += (handlers[i].irq_info[j].high + handlers[i].irq_info[j].low); &#125; seq_printf(m, "\n\tTotal = %d\n", total); return 0;&#125;static int irq_count_debugfs_open(struct inode *inode, struct file *file)&#123; struct smb358_charger *chip = inode-&gt;i_private; return single_open(file, show_irq_count, chip);&#125;static const struct file_operations irq_count_debugfs_ops = &#123; .owner = THIS_MODULE, .open = irq_count_debugfs_open, .read = seq_read, .llseek = seq_lseek, .release = single_release,&#125;;static int get_reg(void *data, u64 *val)&#123; struct smb358_charger *chip = data; int rc; u8 temp; rc = smb358_read_reg(chip, chip-&gt;peek_poke_address, &amp;temp); if (rc &lt; 0) &#123; dev_err(chip-&gt;dev, "Couldn't read reg %x rc = %d\n", chip-&gt;peek_poke_address, rc); return -EAGAIN; &#125; *val = temp; return 0;&#125;static int set_reg(void *data, u64 val)&#123; struct smb358_charger *chip = data; int rc; u8 temp; temp = (u8) val; rc = smb358_write_reg(chip, chip-&gt;peek_poke_address, temp); if (rc &lt; 0) &#123; dev_err(chip-&gt;dev, "Couldn't write 0x%02x to 0x%02x rc= %d\n", chip-&gt;peek_poke_address, temp, rc); return -EAGAIN; &#125; return 0;&#125;DEFINE_SIMPLE_ATTRIBUTE(poke_poke_debug_ops, get_reg, set_reg, "0x%02llx\n");static int force_irq_set(void *data, u64 val)&#123; struct smb358_charger *chip = data; smb358_chg_stat_handler(chip-&gt;client-&gt;irq, data); return 0;&#125;DEFINE_SIMPLE_ATTRIBUTE(force_irq_ops, NULL, force_irq_set, "0x%02llx\n");#endif#ifdef DEBUGstatic void dump_regs(struct smb358_charger *chip)&#123; int rc; u8 reg; u8 addr; for (addr = 0; addr &lt;= LAST_CNFG_REG; addr++) &#123; rc = smb358_read_reg(chip, addr, &amp;reg); if (rc) dev_err(chip-&gt;dev, "Couldn't read 0x%02x rc = %d\n", addr, rc); else pr_debug("0x%02x = 0x%02x\n", addr, reg); &#125; for (addr = FIRST_STATUS_REG; addr &lt;= LAST_STATUS_REG; addr++) &#123; rc = smb358_read_reg(chip, addr, &amp;reg); if (rc) dev_err(chip-&gt;dev, "Couldn't read 0x%02x rc = %d\n", addr, rc); else pr_debug("0x%02x = 0x%02x\n", addr, reg); &#125; for (addr = FIRST_CMD_REG; addr &lt;= LAST_CMD_REG; addr++) &#123; rc = smb358_read_reg(chip, addr, &amp;reg); if (rc) dev_err(chip-&gt;dev, "Couldn't read 0x%02x rc = %d\n", addr, rc); else pr_debug("0x%02x = 0x%02x\n", addr, reg); &#125;&#125;#elsestatic void dump_regs(struct smb358_charger *chip)&#123;&#125;#endifstatic int smb_parse_batt_id(struct smb358_charger *chip)&#123; int rc = 0, rpull = 0, vref = 0; int64_t denom, batt_id_uv, numerator; struct device_node *node = chip-&gt;dev-&gt;of_node; struct qpnp_vadc_result result; rc = of_property_read_u32(node, "qcom,batt-id-vref-uv", &amp;vref); if (rc &lt; 0) &#123; dev_err(chip-&gt;dev, "Couldn't read batt-id-vref-uv rc=%d\n", rc); return rc; &#125; rc = of_property_read_u32(node, "qcom,batt-id-rpullup-kohm", &amp;rpull); if (rc &lt; 0) &#123; dev_err(chip-&gt;dev, "Couldn't read batt-id-rpullup-kohm rc=%d\n", rc); return rc; &#125; /* read battery ID */ rc = qpnp_vadc_read(chip-&gt;vadc_dev, LR_MUX2_BAT_ID, &amp;result); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't read batt id channel=%d, rc=%d\n", LR_MUX2_BAT_ID, rc); return rc; &#125; batt_id_uv = result.physical; if (batt_id_uv == 0) &#123; /*vadc not correct or batt id line grounded, report 0 kohms */ dev_warn(chip-&gt;dev, "batt_id_uv=0, batt-id grounded\n"); return 0; &#125; numerator = batt_id_uv * rpull * 1000; denom = vref - batt_id_uv; /* batt id connector might be open, return 0 kohms */ if (denom == 0) return 0; chip-&gt;connected_rid = div64_s64(numerator, denom); dev_dbg(chip-&gt;dev, "batt_id_voltage=%lld numerator=%lld denom=%lld connected_rid=%d\n", batt_id_uv, numerator, denom, chip-&gt;connected_rid); return 0;&#125;static int smb_parse_dt(struct smb358_charger *chip)&#123; int rc; enum of_gpio_flags gpio_flags; struct device_node *node = chip-&gt;dev-&gt;of_node; int batt_present_degree_negative; if (!node) &#123; dev_err(chip-&gt;dev, "device tree info. missing\n"); return -EINVAL; &#125; chip-&gt;charging_disabled = of_property_read_bool(node, "qcom,charger-disabled"); chip-&gt;inhibit_disabled = of_property_read_bool(node, "qcom,chg-inhibit-disabled"); chip-&gt;chg_autonomous_mode = of_property_read_bool(node, "qcom,chg-autonomous-mode"); chip-&gt;disable_apsd = of_property_read_bool(node, "qcom,disable-apsd"); chip-&gt;using_pmic_therm = of_property_read_bool(node, "qcom,using-pmic-therm"); chip-&gt;pmic_vbat_sns = of_property_read_bool(node, "qcom,using-vbat-sns"); chip-&gt;bms_controlled_charging = of_property_read_bool(node, "qcom,bms-controlled-charging"); rc = of_property_read_string(node, "qcom,bms-psy-name", &amp;chip-&gt;bms_psy_name); if (rc) chip-&gt;bms_psy_name = NULL; chip-&gt;chg_valid_gpio = of_get_named_gpio_flags(node, "qcom,chg-valid-gpio", 0, &amp;gpio_flags); if (!gpio_is_valid(chip-&gt;chg_valid_gpio)) dev_dbg(chip-&gt;dev, "Invalid chg-valid-gpio"); else chip-&gt;chg_valid_act_low = gpio_flags &amp; OF_GPIO_ACTIVE_LOW; rc = of_property_read_u32(node, "qcom,fastchg-current-max-ma", &amp;chip-&gt;fastchg_current_max_ma); if (rc) chip-&gt;fastchg_current_max_ma = SMB358_FAST_CHG_MAX_MA; chip-&gt;iterm_disabled = of_property_read_bool(node, "qcom,iterm-disabled"); rc = of_property_read_u32(node, "qcom,iterm-ma", &amp;chip-&gt;iterm_ma); if (rc &lt; 0) chip-&gt;iterm_ma = -EINVAL; rc = of_property_read_u32(node, "qcom,float-voltage-mv", &amp;chip-&gt;vfloat_mv); if (rc &lt; 0) &#123; chip-&gt;vfloat_mv = -EINVAL; pr_err("float-voltage-mv property missing, exit\n"); return -EINVAL; &#125; rc = of_property_read_u32(node, "qcom,recharge-mv", &amp;chip-&gt;recharge_mv); if (rc &lt; 0) chip-&gt;recharge_mv = -EINVAL; chip-&gt;recharge_disabled = of_property_read_bool(node, "qcom,recharge-disabled"); rc = of_property_read_u32(node, "qcom,cold-bat-decidegc", &amp;chip-&gt;cold_bat_decidegc); if (rc &lt; 0) chip-&gt;cold_bat_decidegc = -EINVAL; rc = of_property_read_u32(node, "qcom,hot-bat-decidegc", &amp;chip-&gt;hot_bat_decidegc); if (rc &lt; 0) chip-&gt;hot_bat_decidegc = -EINVAL; rc = of_property_read_u32(node, "qcom,warm-bat-decidegc", &amp;chip-&gt;warm_bat_decidegc); rc |= of_property_read_u32(node, "qcom,cool-bat-decidegc", &amp;chip-&gt;cool_bat_decidegc); if (!rc) &#123; rc = of_property_read_u32(node, "qcom,cool-bat-mv", &amp;chip-&gt;cool_bat_mv); rc |= of_property_read_u32(node, "qcom,warm-bat-mv", &amp;chip-&gt;warm_bat_mv); rc |= of_property_read_u32(node, "qcom,cool-bat-ma", &amp;chip-&gt;cool_bat_ma); rc |= of_property_read_u32(node, "qcom,warm-bat-ma", &amp;chip-&gt;warm_bat_ma); if (rc) chip-&gt;jeita_supported = false; else chip-&gt;jeita_supported = true; &#125; pr_debug("jeita_supported = %d", chip-&gt;jeita_supported); rc = of_property_read_u32(node, "qcom,bat-present-decidegc", &amp;batt_present_degree_negative); if (rc &lt; 0) chip-&gt;bat_present_decidegc = -EINVAL; else chip-&gt;bat_present_decidegc = -batt_present_degree_negative; if (of_get_property(node, "qcom,vcc-i2c-supply", NULL)) &#123; chip-&gt;vcc_i2c = devm_regulator_get(chip-&gt;dev, "vcc-i2c"); if (IS_ERR(chip-&gt;vcc_i2c)) &#123; dev_err(chip-&gt;dev, "%s: Failed to get vcc_i2c regulator\n", __func__); return PTR_ERR(chip-&gt;vcc_i2c); &#125; &#125; chip-&gt;skip_usb_suspend_for_fake_battery = of_property_read_bool(node, "qcom,skip-usb-suspend-for-fake-battery"); if (!chip-&gt;skip_usb_suspend_for_fake_battery) &#123; if (!chip-&gt;vadc_dev) &#123; dev_err(chip-&gt;dev, "VADC device not present with usb suspend on fake battery\n"); return -EINVAL; &#125; rc = smb_parse_batt_id(chip); if (rc) &#123; dev_err(chip-&gt;dev, "failed to read batt-id rc=%d\n", rc); return rc; &#125; &#125; pr_debug("inhibit-disabled = %d, recharge-disabled = %d, recharge-mv = %d,", chip-&gt;inhibit_disabled, chip-&gt;recharge_disabled, chip-&gt;recharge_mv); pr_debug("vfloat-mv = %d, iterm-disabled = %d,", chip-&gt;vfloat_mv, chip-&gt;iterm_disabled); pr_debug("fastchg-current = %d, charging-disabled = %d,", chip-&gt;fastchg_current_max_ma, chip-&gt;charging_disabled); pr_debug("disable-apsd = %d bms = %s cold-bat-degree = %d,", chip-&gt;disable_apsd, chip-&gt;bms_psy_name, chip-&gt;cold_bat_decidegc); pr_debug("hot-bat-degree = %d, bat-present-decidegc = %d\n", chip-&gt;hot_bat_decidegc, chip-&gt;bat_present_decidegc); return 0;&#125;static int determine_initial_state(struct smb358_charger *chip)&#123; int rc; u8 reg = 0; rc = smb358_read_reg(chip, IRQ_B_REG, &amp;reg); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't read IRQ_B rc = %d\n", rc); goto fail_init_status; &#125; rc = smb358_read_reg(chip, IRQ_C_REG, &amp;reg); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't read IRQ_C rc = %d\n", rc); goto fail_init_status; &#125; chip-&gt;batt_full = (reg &amp; IRQ_C_TERM_BIT) ? true : false; rc = smb358_read_reg(chip, IRQ_A_REG, &amp;reg); if (rc &lt; 0) &#123; dev_err(chip-&gt;dev, "Couldn't read irq A rc = %d\n", rc); return rc; &#125;#if 0 /* For current design, can ignore this */ if (reg &amp; IRQ_A_HOT_HARD_BIT) chip-&gt;batt_hot = true; if (reg &amp; IRQ_A_COLD_HARD_BIT) chip-&gt;batt_cold = true; if (reg &amp; IRQ_A_HOT_SOFT_BIT) chip-&gt;batt_warm = true; if (reg &amp; IRQ_A_COLD_SOFT_BIT) chip-&gt;batt_cool = true;#endif rc = smb358_read_reg(chip, IRQ_E_REG, &amp;reg); if (rc) &#123; dev_err(chip-&gt;dev, "Couldn't read IRQ_E rc = %d\n", rc); goto fail_init_status; &#125; if (reg &amp; IRQ_E_INPUT_UV_BIT) &#123; chg_uv(chip, 1); &#125; else &#123; chg_uv(chip, 0); apsd_complete(chip, 1); &#125; return 0;fail_init_status: dev_err(chip-&gt;dev, "Couldn't determine initial status\n"); return rc;&#125;#if defined(CONFIG_DEBUG_FS)static void smb358_debugfs_init(struct smb358_charger *chip)&#123; int rc; chip-&gt;debug_root = debugfs_create_dir("smb358", NULL); if (!chip-&gt;debug_root) dev_err(chip-&gt;dev, "Couldn't create debug dir\n"); if (chip-&gt;debug_root) &#123; struct dentry *ent; ent = debugfs_create_file("config_registers", S_IFREG | S_IRUGO, chip-&gt;debug_root, chip, &amp;cnfg_debugfs_ops); if (!ent || IS_ERR(ent)) &#123; rc = PTR_ERR(ent); dev_err(chip-&gt;dev, "Couldn't create cnfg debug file rc = %d\n", rc); &#125; ent = debugfs_create_file("status_registers", S_IFREG | S_IRUGO, chip-&gt;debug_root, chip, &amp;status_debugfs_ops); if (!ent || IS_ERR(ent)) &#123; rc = PTR_ERR(ent); dev_err(chip-&gt;dev, "Couldn't create status debug file rc = %d\n", rc); &#125; ent = debugfs_create_file("cmd_registers", S_IFREG | S_IRUGO, chip-&gt;debug_root, chip, &amp;cmd_debugfs_ops); if (!ent || IS_ERR(ent)) &#123; rc = PTR_ERR(ent); dev_err(chip-&gt;dev, "Couldn't create cmd debug file rc = %d\n", rc); &#125; ent = debugfs_create_x32("address", S_IFREG | S_IWUSR | S_IRUGO, chip-&gt;debug_root, &amp;(chip-&gt;peek_poke_address)); if (!ent || IS_ERR(ent)) &#123; rc = PTR_ERR(ent); dev_err(chip-&gt;dev, "Couldn't create address debug file rc = %d\n", rc); &#125; ent = debugfs_create_file("data", S_IFREG | S_IWUSR | S_IRUGO, chip-&gt;debug_root, chip, &amp;poke_poke_debug_ops); if (!ent || IS_ERR(ent)) &#123; rc = PTR_ERR(ent); dev_err(chip-&gt;dev, "Couldn't create data debug file rc = %d\n", rc); &#125; ent = debugfs_create_file("force_irq", S_IFREG | S_IWUSR | S_IRUGO, chip-&gt;debug_root, chip, &amp;force_irq_ops); if (!ent || IS_ERR(ent)) &#123; rc = PTR_ERR(ent); dev_err(chip-&gt;dev, "Couldn't create force_irq debug file rc =%d\n", rc); &#125; ent = debugfs_create_file("irq_count", S_IFREG | S_IRUGO, chip-&gt;debug_root, chip, &amp;irq_count_debugfs_ops); if (!ent || IS_ERR(ent)) &#123; rc = PTR_ERR(ent); dev_err(chip-&gt;dev, "Couldn't create cnfg irq_count file rc = %d\n", rc); &#125; &#125;&#125;#elsestatic void smb358_debugfs_init(struct smb358_charger *chip)&#123;&#125;#endif#define SMB_I2C_VTG_MIN_UV 1800000#define SMB_I2C_VTG_MAX_UV 1800000static int smb358_charger_probe(struct i2c_client *client, const struct i2c_device_id *id)&#123; int rc, irq; struct smb358_charger *chip; struct power_supply *usb_psy; u8 reg = 0; usb_psy = power_supply_get_by_name("usb"); if (!usb_psy) &#123; dev_dbg(&amp;client-&gt;dev, "USB psy not found; deferring probe\n"); return -EPROBE_DEFER; &#125; chip = devm_kzalloc(&amp;client-&gt;dev, sizeof(*chip), GFP_KERNEL); if (!chip) &#123; dev_err(&amp;client-&gt;dev, "Couldn't allocate memory\n"); return -ENOMEM; &#125; chip-&gt;client = client; chip-&gt;dev = &amp;client-&gt;dev; chip-&gt;usb_psy = usb_psy; chip-&gt;fake_battery_soc = -EINVAL; if (of_find_property(chip-&gt;dev-&gt;of_node, "qcom,chg-vadc", NULL)) &#123; /* early for VADC get, defer probe if needed */ chip-&gt;vadc_dev = qpnp_get_vadc(chip-&gt;dev, "chg"); if (IS_ERR(chip-&gt;vadc_dev)) &#123; rc = PTR_ERR(chip-&gt;vadc_dev); if (rc != -EPROBE_DEFER) pr_err("vadc property configured incorrectly\n"); return rc; &#125; &#125; rc = smb_parse_dt(chip); if (rc) &#123; dev_err(&amp;client-&gt;dev, "Couldn't parse DT nodes rc=%d\n", rc); return rc; &#125; /* i2c pull up regulator configuration */ if (chip-&gt;vcc_i2c) &#123; if (regulator_count_voltages(chip-&gt;vcc_i2c) &gt; 0) &#123; rc = regulator_set_voltage(chip-&gt;vcc_i2c, SMB_I2C_VTG_MIN_UV, SMB_I2C_VTG_MAX_UV); if (rc) &#123; dev_err(&amp;client-&gt;dev, "regulator vcc_i2c set failed, rc = %d\n", rc); return rc; &#125; &#125; rc = regulator_enable(chip-&gt;vcc_i2c); if (rc) &#123; dev_err(&amp;client-&gt;dev, "Regulator vcc_i2c enable failed rc = %d\n", rc); goto err_set_vtg_i2c; &#125; &#125; mutex_init(&amp;chip-&gt;irq_complete); mutex_init(&amp;chip-&gt;read_write_lock); mutex_init(&amp;chip-&gt;path_suspend_lock); //addeb by zhengtianxing // removed this config, because that make power_supply_register hangup sometime in fllowing. zhangdongyang 20170206 //power_supply_set_charge_type(chip-&gt;usb_psy, POWER_SUPPLY_TYPE_USB); //power_supply_set_present(chip-&gt;usb_psy, 1); /* probe the device to check if its actually connected */ rc = smb358_read_reg(chip, CHG_OTH_CURRENT_CTRL_REG, &amp;reg); if (rc) &#123; pr_err("Failed to detect SMB358, device absent, rc = %d\n", rc); goto err_set_vtg_i2c; &#125; /* using adc_tm for implementing pmic therm */ if (chip-&gt;using_pmic_therm) &#123; chip-&gt;adc_tm_dev = qpnp_get_adc_tm(chip-&gt;dev, "chg"); if (IS_ERR(chip-&gt;adc_tm_dev)) &#123; rc = PTR_ERR(chip-&gt;adc_tm_dev); if (rc != -EPROBE_DEFER) pr_err("adc_tm property missing\n"); return rc; &#125; &#125; i2c_set_clientdata(client, chip); chip-&gt;batt_psy.name = "battery"; chip-&gt;batt_psy.type = POWER_SUPPLY_TYPE_BATTERY; chip-&gt;batt_psy.get_property = smb358_battery_get_property; chip-&gt;batt_psy.set_property = smb358_battery_set_property; chip-&gt;batt_psy.property_is_writeable = smb358_batt_property_is_writeable; chip-&gt;batt_psy.properties = smb358_battery_properties; chip-&gt;batt_psy.num_properties = ARRAY_SIZE(smb358_battery_properties); chip-&gt;batt_psy.external_power_changed = smb358_external_power_changed; chip-&gt;batt_psy.supplied_to = pm_batt_supplied_to; chip-&gt;batt_psy.num_supplicants = ARRAY_SIZE(pm_batt_supplied_to); chip-&gt;resume_completed = true; rc = power_supply_register(chip-&gt;dev, &amp;chip-&gt;batt_psy); if (rc &lt; 0) &#123; dev_err(&amp;client-&gt;dev, "Couldn't register batt psy rc = %d\n", rc); goto err_set_vtg_i2c; &#125; dump_regs(chip); rc = smb358_regulator_init(chip); if (rc) &#123; dev_err(&amp;client-&gt;dev, "Couldn't initialize smb358 ragulator rc=%d\n", rc); goto fail_regulator_register; &#125; smb358_chg_stat_handler(0, (void *)chip); rc = smb358_hw_init(chip); if (rc) &#123; dev_err(&amp;client-&gt;dev, "Couldn't intialize hardware rc=%d\n", rc); goto fail_smb358_hw_init; &#125; rc = determine_initial_state(chip); if (rc) &#123; dev_err(&amp;client-&gt;dev, "Couldn't determine initial state rc=%d\n", rc); goto fail_smb358_hw_init; &#125; /* We will not use it by default */ if (gpio_is_valid(chip-&gt;chg_valid_gpio)) &#123; rc = gpio_request(chip-&gt;chg_valid_gpio, "smb358_chg_valid"); if (rc) &#123; dev_err(&amp;client-&gt;dev, "gpio_request for %d failed rc=%d\n", chip-&gt;chg_valid_gpio, rc); goto fail_chg_valid_irq; &#125; irq = gpio_to_irq(chip-&gt;chg_valid_gpio); if (irq &lt; 0) &#123; dev_err(&amp;client-&gt;dev, "Invalid chg_valid irq = %d\n", irq); goto fail_chg_valid_irq; &#125; rc = devm_request_threaded_irq(&amp;client-&gt;dev, irq, NULL, smb358_chg_valid_handler, IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING, "smb358_chg_valid_irq", chip); if (rc) &#123; dev_err(&amp;client-&gt;dev, "Failed request_irq irq=%d, gpio=%d rc=%d\n", irq, chip-&gt;chg_valid_gpio, rc); goto fail_chg_valid_irq; &#125; smb358_chg_valid_handler(irq, chip); enable_irq_wake(irq); &#125; chip-&gt;irq_gpio = of_get_named_gpio_flags(chip-&gt;dev-&gt;of_node, "qcom,irq-gpio", 0, NULL); /* STAT irq configuration */ if (gpio_is_valid(chip-&gt;irq_gpio)) &#123; rc = gpio_request(chip-&gt;irq_gpio, "smb358_irq"); if (rc) &#123; dev_err(&amp;client-&gt;dev, "irq gpio request failed, rc=%d", rc); goto fail_smb358_hw_init; &#125; rc = gpio_direction_input(chip-&gt;irq_gpio); if (rc) &#123; dev_err(&amp;client-&gt;dev, "set_direction for irq gpio failed\n"); goto fail_irq_gpio; &#125; irq = gpio_to_irq(chip-&gt;irq_gpio); if (irq &lt; 0) &#123; dev_err(&amp;client-&gt;dev, "Invalid irq_gpio irq = %d\n", irq); goto fail_irq_gpio; &#125; rc = devm_request_threaded_irq(&amp;client-&gt;dev, irq, NULL, smb358_chg_stat_handler, IRQF_TRIGGER_FALLING | IRQF_ONESHOT, "smb358_chg_stat_irq", chip); if (rc) &#123; dev_err(&amp;client-&gt;dev, "Failed STAT irq=%d request rc = %d\n", irq, rc); goto fail_irq_gpio; &#125; enable_irq_wake(irq); &#125; else &#123; goto fail_irq_gpio; &#125; if (chip-&gt;using_pmic_therm) &#123; if (!chip-&gt;jeita_supported) &#123; /* add hot/cold temperature monitor */ chip-&gt;adc_param.low_temp = chip-&gt;cold_bat_decidegc; chip-&gt;adc_param.high_temp = chip-&gt;hot_bat_decidegc; &#125; else &#123; chip-&gt;adc_param.low_temp = chip-&gt;cool_bat_decidegc; chip-&gt;adc_param.high_temp = chip-&gt;warm_bat_decidegc; &#125; chip-&gt;adc_param.timer_interval = ADC_MEAS2_INTERVAL_1S; chip-&gt;adc_param.state_request = ADC_TM_HIGH_LOW_THR_ENABLE; chip-&gt;adc_param.btm_ctx = chip; chip-&gt;adc_param.threshold_notification = smb_chg_adc_notification;#ifdef CONFIG_FOR_BROBDMOBI_R700 chip-&gt;adc_param.channel = P_MUX6_1_1;#else chip-&gt;adc_param.channel = LR_MUX1_BATT_THERM;#endif /* update battery missing info in tm_channel_measure*/ rc = qpnp_adc_tm_channel_measure(chip-&gt;adc_tm_dev, &amp;chip-&gt;adc_param); if (rc) pr_err("requesting ADC error %d\n", rc); &#125; smb358_debugfs_init(chip); dump_regs(chip); dev_info(chip-&gt;dev, "SMB358 successfully probed. charger=%d, batt=%d\n", chip-&gt;chg_present, smb358_get_prop_batt_present(chip)); return 0;fail_chg_valid_irq: if (gpio_is_valid(chip-&gt;chg_valid_gpio)) gpio_free(chip-&gt;chg_valid_gpio);fail_irq_gpio: if (gpio_is_valid(chip-&gt;irq_gpio)) gpio_free(chip-&gt;irq_gpio);fail_smb358_hw_init: regulator_unregister(chip-&gt;otg_vreg.rdev);fail_regulator_register: power_supply_unregister(&amp;chip-&gt;batt_psy);err_set_vtg_i2c: if (chip-&gt;vcc_i2c) if (regulator_count_voltages(chip-&gt;vcc_i2c) &gt; 0) regulator_set_voltage(chip-&gt;vcc_i2c, 0, SMB_I2C_VTG_MAX_UV); return rc;&#125;static int smb358_charger_remove(struct i2c_client *client)&#123; struct smb358_charger *chip = i2c_get_clientdata(client); power_supply_unregister(&amp;chip-&gt;batt_psy); if (gpio_is_valid(chip-&gt;chg_valid_gpio)) gpio_free(chip-&gt;chg_valid_gpio); if (chip-&gt;vcc_i2c) regulator_disable(chip-&gt;vcc_i2c); mutex_destroy(&amp;chip-&gt;irq_complete); debugfs_remove_recursive(chip-&gt;debug_root); return 0;&#125;static int smb358_suspend(struct device *dev)&#123; struct i2c_client *client = to_i2c_client(dev); struct smb358_charger *chip = i2c_get_clientdata(client); int rc; int i; for (i = 0; i &lt; 2; i++) &#123; rc = smb358_read_reg(chip, FAULT_INT_REG + i, &amp;chip-&gt;irq_cfg_mask[i]); if (rc) dev_err(chip-&gt;dev, "Couldn't save irq cfg regs rc = %d\n", rc); &#125; /* enable wake up IRQs */ rc = smb358_write_reg(chip, FAULT_INT_REG, FAULT_INT_HOT_COLD_HARD_BIT | FAULT_INT_INPUT_UV_BIT); if (rc &lt; 0) dev_err(chip-&gt;dev, "Couldn't set fault_irq_cfg rc = %d\n", rc); rc = smb358_write_reg(chip, STATUS_INT_REG, STATUS_INT_LOW_BATT_BIT | STATUS_INT_MISSING_BATT_BIT | STATUS_INT_CHGING_BIT | STATUS_INT_INOK_BIT | STATUS_INT_OTG_DETECT_BIT | STATUS_INT_CHG_INHI_BIT); if (rc &lt; 0) dev_err(chip-&gt;dev, "Couldn't set status_irq_cfg rc = %d\n", rc); mutex_lock(&amp;chip-&gt;irq_complete); if (chip-&gt;vcc_i2c) &#123; rc = regulator_disable(chip-&gt;vcc_i2c); if (rc) &#123; dev_err(chip-&gt;dev, "Regulator vcc_i2c disable failed rc=%d\n", rc); mutex_unlock(&amp;chip-&gt;irq_complete); return rc; &#125; &#125; chip-&gt;resume_completed = false; mutex_unlock(&amp;chip-&gt;irq_complete); return 0;&#125;static int smb358_suspend_noirq(struct device *dev)&#123; struct i2c_client *client = to_i2c_client(dev); struct smb358_charger *chip = i2c_get_clientdata(client); if (chip-&gt;irq_waiting) &#123; pr_err_ratelimited("Aborting suspend, an interrupt was detected while suspending\n"); return -EBUSY; &#125; return 0;&#125;static int smb358_resume(struct device *dev)&#123; struct i2c_client *client = to_i2c_client(dev); struct smb358_charger *chip = i2c_get_clientdata(client); int rc; int i; if (chip-&gt;vcc_i2c) &#123; rc = regulator_enable(chip-&gt;vcc_i2c); if (rc) &#123; dev_err(chip-&gt;dev, "Regulator vcc_i2c enable failed rc=%d\n", rc); return rc; &#125; &#125; /* Restore IRQ config */ for (i = 0; i &lt; 2; i++) &#123; rc = smb358_write_reg(chip, FAULT_INT_REG + i, chip-&gt;irq_cfg_mask[i]); if (rc) dev_err(chip-&gt;dev, "Couldn't restore irq cfg regs rc=%d\n", rc); &#125; mutex_lock(&amp;chip-&gt;irq_complete); chip-&gt;resume_completed = true; mutex_unlock(&amp;chip-&gt;irq_complete); if (chip-&gt;irq_waiting) &#123; smb358_chg_stat_handler(client-&gt;irq, chip); enable_irq(client-&gt;irq); &#125; return 0;&#125;static const struct dev_pm_ops smb358_pm_ops = &#123; .suspend = smb358_suspend, .suspend_noirq = smb358_suspend_noirq, .resume = smb358_resume,&#125;;static struct of_device_id smb358_match_table[] = &#123; &#123; .compatible = "qcom,smb358-charger",&#125;, &#123; &#125;,&#125;;static const struct i2c_device_id smb358_charger_id[] = &#123; &#123;"smb358-charger", 0&#125;, &#123;&#125;,&#125;;MODULE_DEVICE_TABLE(i2c, smb358_charger_id);static struct i2c_driver smb358_charger_driver = &#123; .driver = &#123; .name = "smb358-charger", .owner = THIS_MODULE, .of_match_table = smb358_match_table, .pm = &amp;smb358_pm_ops, &#125;, .probe = smb358_charger_probe, .remove = smb358_charger_remove, .id_table = smb358_charger_id,&#125;;module_i2c_driver(smb358_charger_driver);MODULE_DESCRIPTION("SMB358 Charger");MODULE_LICENSE("GPL v2");MODULE_ALIAS("i2c:smb358-charger");]]></content>
      <categories>
        <category>linux device driver</category>
      </categories>
      <tags>
        <tag>linux device driver</tag>
        <tag>charger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rtl8192移植以及802.11相关概念]]></title>
    <url>%2F2019%2F05%2F09%2Frtl8192%E7%A7%BB%E6%A4%8D%E4%BB%A5%E5%8F%8A802-11%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[工作内容原理介绍 根据realtek提供的SDK移植到我们的mdm9640平台 。 文件介绍 RTL8192软件SDK中包含如下的文件： configuration-scripts 初始化wifi的相关脚本 DriverSrcPkg/Driver对应内核模块代码 DriverSrcPkg/Users对应realtek芯片控制用的相关程序 修改编译环境详细修改参数请参考:RTL819x_AIO_porting_guide.pdf platform.mk中添加如下平台相关选项: 12345678910ifeq ($(CONFIG_PLATFORM),ARM_QUALCOMM_9x15) EXTRA_CFLAGS += -D_LITTLE_ENDIAN_ -DSMP_SYNC ARCH := arm KSRC ?= $&#123;ANDROID_KERN_DIR&#125; CROSS_COMPILE ?= arm-oe-linux-gnueabi- EXTRA_CFLAGS += -DCONFIG_RTL_80211D_SUPPORT EXTRA_CFLAGS += -DCONFIG_RTL_CLIENT_MODE_SUPPORT EXTRA_CFLAGS += -DCONFIG_RTL_REPEATER_MODE_SUPPORT -DSDIO_2_PORT RTL8192CD_NUM_VWLAN := 1 endif 内置PA,外置PA配置修改config.mk中的如下选项: 123456# If Use External PA, LNA ?CONFIG_EXT_PA :=yCONFIG_EXT_LNA :=y# If not Use External PA, LNA ?CONFIG_EXT_PA :=nCONFIG_EXT_LNA :=n 驱动加载及测试加载驱动 insmod rtl8192es.ko 启动端口 ifconfig wlan0 up搜索wifi，如果能正常搜索到，则说明驱动正常 ssid消失 调试过程中出现ssid经常消失的情况，为外部PA配置问题，参照驱动编译中的PA配置即可 测试 通过configuration-scripts中的脚本可以测试相关功能 编译到工程 当wifi驱动 工作正常后可以将其添加到工程，添加方法如下：oe-core/meta-msm/recipes/images/mdm9607-image.inc 中添加 IMAGE_INSTALL += “rtl8192” 802.11相关概念 BSS:基本服务集,一个AP + client STAsDSS:分布式系统服务ESS:扩展服务集,多个共享ESSID的BSSIBSS:独立BSSESSID :网络名称，同SSIDBA :块确认，对多个MPDU进行确认MESH: 无线网格网络ad-hoc: 点对点连接CCA:clear channel assessment 空闲信道评估OFDM:正交频分复用每个子载相互正交802.11n使用OFDM，子载波间隔31.25kQAM :正交振幅调制，Quadrature Amplitude Modulation的缩写GI: 保护间隔short GI: 400nslong GI : 800nsA-MPDU :MAC层PDU包聚合打包多个802.11帧到一个MPDU ,最大64KBA-MSDU :MAC层SDU包聚合硬件实现，打包多个ethernet 帧到一个MSDU,最大8KB当使用A-MPDU时，最大A-MSDU子帧不能大于4KB，因为每个A-MPDU子帧的最大长度是4KB 支持的速率影响速率的因素：编码方式 调制方式 保护间隔 带宽 802.11b 1, 2, 5.5, 11(11Mchip/s) / 8chip * 8bit = 11Mbit/s 802.11g 6, 9, 12, 18, 24, 36, 48, 54(1秒/4微秒）×（6bit×48×3/4）= 54Mbit/s 802.11n 20Mhz 400 ns GI : 7.2, 14.4, 21.7, 28.9, 43.3, 57.8, 65, 72.2(1秒/3.6微秒）×（6bit×52×5/6）= 72.2Mbit/s800 ns GI : 6.5, 13, 19.5, 26, 39, 52, 58.5, 65(1秒/4微秒）×（6bit×52×5/6）= 65Mbit/s 802.11n 40MHz 400 ns GI : 15, 30, 45, 60, 90, 120, 135, 150(1秒/3.6微秒）×（6bit×108×5/6）= 150Mbit/s800 ns GI : 13.5, 27, 40.5, 54, 81, 108, 121.5, 135(1秒/4微秒）×（6bit×108×5/6）= 135Mbit/s 802.11n MIMO 1×1 支持MCS0 – MSC7 150Mbps2×2 支持MCS0 – MSC15 300Mbps3×3 支持MCS0 – MSC23 450Mbps4×4 支持MCS0 – MSC31 600Mbps 802.ac 最高可达6.9Gbps 802.11包格式 PPDU : PLCP + PSDUPLCP : PLCP Preamble + PLCP HeaderPSDU : MPDU or A-MPDUMPDU : MAC Header + MSDUPSDU最大长度65535字节MSDU最大长度2304字节A-MSDU最大长度7935字节 数据帧 -Data -Data + CF-Ack -Data + CF-Poll -Data + CF-Ack + CF-Poll 控制帧 -BAQ -BA -RTS -CTS -ACK -CF-End -CF-End+CF-Ack 管理帧 -Beacon -Probe request -Probe response -Authentication -Association Request -Association Response -ReassociationRequest -ReassociationResponse -Disassociation -Deauthentication -ATIM AP 接入过程 STA 传输方向 AP &lt; Beacon Probe request &gt; &lt; Probe Response Auth Request &gt; &lt; Authentication Response Association Request &gt; &lt; Association Response Data &gt; &lt; Data … &gt;&lt; … SFEsfe 介绍全称：Shortcut Forward Engine，快捷转发引擎用于加速LAN和WAN端口之间的数据转发，当以太网包匹配到一个SFE实体时，将不会进行Linux kernel网络栈的路由而直接发送，从而减少CPU的使用 sfe包聚合功能 sfe的在接收到的包数量达到一定的阈值或定时器超时时才会进行数据包的发送相关代码如下： 12345678if(aggr_params[cm-&gt;index].skb_head) dev_queue_xmit_list(aggr_params[cm-&gt;index].skb_head); elsLibreOffice Writer，在窗口右e dev_queue_xmit(new_skb); /* Reset the params. */ aggr_params[cm-&gt;index].curr_dl_skb_num = 0; aggr_params[cm-&gt;index].skb_head = NULL; aggr_params[cm-&gt;index].skb_tail = NULL; 当包数量大于一个时会调用dev_queue_xmit_list，当包数量为１时，会调用dev_queue_xmit,dev_queue_xmit_list发送整条以太网帧数据链表，需要特殊的驱动支持。 关闭sfe的包聚合功能 echo 1 &gt; /proc/sys/debug/sfe/thresholdecho 10000 &gt; /proc/sys/debug/sfe/timeout_value]]></content>
      <categories>
        <category>网络驱动</category>
      </categories>
      <tags>
        <tag>linux device driver</tag>
        <tag>wifi</tag>
        <tag>rtl8192</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The New World]]></title>
    <url>%2F2019%2F05%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to my blog! This is my first personal blog. The New World职业生涯 我从事linux驱动开发已经一年时间，之前也搭建过一个博客写了一些工作以及学习上的事，但是后来也不了了之，没能坚持的下去现在我已经提了离职，准备去一个新公司开始新的生涯，所以准备这次重新开始，记录我的职业生涯 人生 我2019/5/2有了我一件人生大事，我买房了，在南通。尽管贷款了151W,还贷30年,每月要还8200+，但是还是很开心。感觉我的人生踏入了一个新的阶段。以后的以后，请一定要加油！！！]]></content>
      <categories>
        <category>生活点滴</category>
      </categories>
  </entry>
</search>
